include "std.rasm"
include "sdl.rasm"

extern "printf"

enum Color {
    White,
    Yellow,
    Red,
    Green,
    Blue
}

struct Brick {
    x: i32,
    y: i32,
    color: Color
}

enum XDirection {
    Left,
    Right
}

enum YDirection {
    Up,
    Down
}

struct Ball {
    x: i32,
    y: i32,
    xDir: XDirection,
    yDir: YDirection
}

struct World {
    bricks: Vec<Brick>,
    ball: Ball,
    bar: Bar
}

struct Bar {
    x: i32,
    velocity: i32,
}

const WIDTH = 1024;
const HEIGHT = 768;
const BRICKWIDTH = 30;
const BRICKHEIGHT = 10;
const BARWIDTH = 50;
const BARHEIGHT = 20;

sdlInit();

let bricks = zip(vecRange(0, 30), vecRange(0, 10), {x, y -> Brick(mul(x, BRICKWIDTH), mul(y, BRICKHEIGHT) , Color::Yellow()); });
let initialWorld = World(bricks, Ball(1000, 10, XDirection::Right(), YDirection::Up()), Bar(500, 0));

runOrError(sdlCreateWindow("Bricks", 100, 100, WIDTH, HEIGHT), "SDL_CreateWindow Error: %s\n", { win ->
    runOrError(sdlCreateRenderer(win), "SDL_CreateRenderer Error: %s\n", { ren ->

        // TODO a trick to create the function, since for now I can't call it with a $call macro in asm...
        singleLoop(ren, initialWorld, { event,world -> world;}, { ren, world -> });

        loop(ren, initialWorld,
            { event, world -> update(event, world);},
            { ren, world -> render(ren, world);}
        );

        sdlDestroyRenderer(ren);
        sdlDestroyWindow(win);
    });
});

fn update(event: Option<KeyEvent>, world: World) -> World {
    //printWorld("update world ",  world);
    let bar = World::bar(world);
    let barPos = Bar::x(bar);
    //println("barPos ", barPos);
    let velocity = Bar::velocity(bar);
    //println("velocity ", velocity);
    //println("newVelocity ", newVelocity);

    let ev = Option::match(event, { e ->
        let key = KeyEvent::key(e);
        let left = if(eq(key, 80), { -> -10; }, { -> 0;});
        let right = if(eq(key, 79), { -> 10; }, { -> 0;});
        add(left, right);
    }, { -> 0;});

    let newVelocity = ev;

    //if(eq(event, 80), { -> sub(velocity, 1); }, { -> if(eq(event, 79), { -> add(velocity, 1); }, { -> velocity;});});

    //Option::run(event, { keyEvent -> println(keyEvent);} { -> });

    let newBarPos = add(barPos, newVelocity);
    //println("newBarPos ", newBarPos);

    let newBar = Bar(newBarPos, newVelocity);

    let ball = World::ball(world);
    let x = Ball::x(ball);
    let y = Ball::y(ball);
    let xDir = Ball::xDir(ball);
    let yDir = Ball::yDir(ball);
    let bricks = World::bricks(world);

    let newX = XDirection::match(xDir, { -> sub(x, 1);} , { -> add(x,1);});
    let newY = YDirection::match(yDir, { -> sub(y, 1);} , { -> add(y,1);});

    let newXDir = if(or(greater(newX, WIDTH), less(newX, 5)), { -> flip(xDir); }, { -> xDir;});
    let newYDir = if(or(greater(newY, HEIGHT), less(newY, 5)), { -> flip(yDir); }, { -> yDir;});

    let newBall = Ball(newX, newY, newXDir, newYDir);

    let collision = collision(bricks, newBall);

    let newBricks = Option::match(collision, { b1 -> filter(bricks, { b2 -> not(eq(b1, b2)); }); }, { -> bricks; });

    let newBall1 = Option::match(collision, { brick -> ballAfterCollision(ball, brick); }, { -> newBall; });

    let newBall2 = if(collides(newX, newY, newBarPos), { -> Ball(newX, newY, flip(newXDir), newYDir);}, { -> newBall1; });

    let newBarVelocity = Bar::velocity(newBar);
    //println("newBarVelocity ", newBarVelocity);

    let newBarPos2 = Bar::x(newBar);
    //println("newBarPos2 ", newBarPos2);

    //exitMain(0);

    World(newBricks, newBall2, newBar);
}

fn println<T>(prefix: str, o: T) {
    print(prefix);
    println(o);
}

fn render(ren: i32, world: World) {
    sdlSetRenderDrawColor(ren, 0, 0, 0, 0);
    sdlRenderClear(ren);
    sdlSetRenderDrawColor(ren, 255, 0, 0, 0);

    let bricks = World::bricks(world);

    forEach(bricks, { brick ->
        let x = Brick::x(brick);
        let y = Brick::y(brick);
        sdlRenderFillRect(ren, SDLRect(add(x, 1), add(y, 1), sub(BRICKWIDTH, 2), sub(BRICKHEIGHT, 2)));
    });

    sdlSetRenderDrawColor(ren, 255, 255, 255, 0);
    let bar = World::bar(world);
    let barPos = Bar::x(bar);
    //println("barPos in renderer: ", barPos);

    let velocity = Bar::velocity(bar);
    //println("velocity in renderer: ", velocity);

    sdlRenderFillRect(ren, SDLRect(barPos, sub(HEIGHT, BARHEIGHT), BARWIDTH, BARHEIGHT));

    let ball = World::ball(world);
    let x = Ball::x(ball);
    let y = Ball::y(ball);

    sdlRenderFillRect(ren, SDLRect(x, y, 5, 5));
}

fn eq(b1: Brick, b2: Brick) -> bool {
    let b1x = Brick::x(b1);
    let b1y = Brick::y(b1);

    let b2x = Brick::x(b2);
    let b2y = Brick::y(b2);

    and(eq(b1x, b2x), eq(b1y, b2y));
}

fn collision(bricks: Vec<Brick>, ball: Ball) -> Option<Brick> {
    let x = Ball::x(ball);
    let y = Ball::y(ball);

    first(filter(bricks, { brick -> collides(x, y, brick); }));
}

fn collides(x: i32, y: i32, brick: Brick) -> bool {
    let bx = Brick::x(brick);
    let by = Brick::y(brick);

    let xColl = and(greater(x, bx), less(x, add(bx, BRICKWIDTH)));
    let yColl = and(greater(y, by), less(y, add(by, BRICKHEIGHT)));

    and(xColl, yColl);
}

fn collides(x: i32, y: i32, barPos: i32) -> bool {
    let bx = barPos;
    let by = sub(HEIGHT, BARHEIGHT);

    let xColl = and(greater(x, bx), less(x, add(bx, BARWIDTH)));
    let yColl = and(greater(y, by), less(y, add(by, BARHEIGHT)));

    and(xColl, yColl);
}

fn ballAfterCollision(ball: Ball, brick: Brick) -> Ball {
    let ballX = Ball::x(ball);
    let ballY = Ball::y(ball);
    let xDir = Ball::xDir(ball);
    let yDir = Ball::yDir(ball);

    let brickX = Brick::x(brick);
    let brickY = Brick::y(brick);

    let xDiff1 = sub(ballX, brickX);
    let xDiff2 = sub(add(brickX, BRICKWIDTH), ballX);
    let yDiff1 = sub(ballY, brickY);
    let yDiff2 = sub(add(brickY, BRICKHEIGHT), ballY);

    let xDiff = min(xDiff1, xDiff2);
    let yDiff = min(yDiff1, yDiff2);

    if(less(xDiff, yDiff), { -> Ball(ballX, ballY, flip(xDir), yDir);}, { -> Ball(ballX, ballY, xDir, flip(yDir));});
}

fn min(a: i32, b: i32) -> i32 {
    ifImmediate(less(a, b), a, b);
}

fn flip(xDir: XDirection) -> XDirection {
    XDirection::match(xDir, { -> XDirection::Right();}, { -> XDirection::Left(); } );
}

fn flip(yDir: YDirection) -> YDirection {
    YDirection::match(yDir, { -> YDirection::Down();}, { -> YDirection::Up(); } );
}

fn worldUpdate(world: World, bricksUpdate: fn(Vec<Brick>) -> Vec<Brick>, ballUpdate: fn(Ball) -> Ball, barPosUpdate: fn(i32) -> i32) -> World {
    let bricks = bricksUpdate(World::bricks(world));
    let ball = ballUpdate(World::ball(world));
    let barPos = barPosUpdate(World::barPos(world));

    World(bricks, ball, barPos);
}

// TODO I don't need the whole world!!!
fn moveBarLeft(world: World) -> World {
    let bricks = World::bricks(world);
    let ball = World::ball(world);
    let barPos = World::barPos(world);

    World(bricks, ball, sub(barPos, 10));
}

// TODO I don't need the whole world!!!
fn moveBarRight(world: World) -> World {
    let bricks = World::bricks(world);
    let ball = World::ball(world);
    let barPos = World::barPos(world);

    World(bricks, ball, add(barPos, 10));
}

fn print(brick: Brick) {
    print("(");
    print(Brick::x(brick));
    print(", ");
    print(Brick::y(brick));
    print(", ");
    print(Brick::color(brick));
    print(")");
}

fn print(color: Color) {
    Color::run( color,
        { -> print("White"); },
        { -> print("Yellow"); },
        { -> print("Red"); },
        { -> print("Green"); },
        { -> print("Blue"); },
    );
}

asm failure(message: str) /{
    $ccall(SDL_GetError)
    $ccall(printf, $message, eax)
    $ccall(SDL_Quit)
    $ccall(exit, 1)
}/

fn runOrError(value: i32, message: str, f: fn(i32) -> ()) {
    ifRun(eq(value,0), { -> failure(message);}, { -> f(value); });
}

fn singleLoop<CTX,WORLD>(ctx: CTX, world: WORLD, updateFun: fn(Option<KeyEvent>, WORLD) -> WORLD, renderFun: fn(CTX, WORLD) -> ()) -> WORLD {
    let event = keyEvent();//Option::Some(KeyEvent(0, KeyState::Down()));

    Option::run(event, { keyEvent ->
        let key = KeyEvent::key(keyEvent);
        ifRun(eq(key, 41), { -> exitMain(0);}, { -> }); // 41 -> ESC
    }, { -> });

    with(updateFun(event, world), { newWorld ->
        renderFun(ctx, newWorld);
        sdlRenderPresent(ctx);
        newWorld;
    });

    /*
    TODO is not supported yet
    let newWorld = update(event, world);
    render(ctx, newWorld);
    sdlRenderPresent(ctx);
    newWorld;
    */
}

asm printWorld(message: str, world: World) /{
    $call(print, $message)
    $call(println, $world:i32)
}/

asm loop<CTX,WORLD>(ctx: CTX, world: WORLD, update: fn(Option<KeyEvent>, WORLD) -> WORLD, render: fn(CTX, WORLD) -> ()) /{
    push    ebx
    push    ecx
    mov     dword ebx, $world
.loop:
    ; $call(print, "world address ")
    ; $call(println, ebx)
    $call(printAllocated)
    $call(printTableSlotsAllocated)
    mov     dword ecx, [ebx]
    ; $call(print, "bricks address ")
    ; $call(println, [ecx])
    ; $call(print, "ball address ")
    ; $call(println, [ecx + 4])
    ; $call(print, "bar address ")
    ; $call(println, [ecx + 8])
    push        dword $render
    push        dword $update
    push        dword ebx
    push        dword $ctx
    call        singleLoop_0
    add         esp, 4 * 4
    mov         dword   ebx, eax
    jmp     .loop
    pop     ecx
    pop     ebx
}/