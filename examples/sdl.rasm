requires "libc"
requires "SDL2"

extern "SDL_CreateRenderer"
extern "SDL_CreateTextureFromSurface"
extern "SDL_CreateWindow"
extern "SDL_Delay"
extern "SDL_DestroyRenderer"
extern "SDL_DestroyTexture"
extern "SDL_DestroyWindow"
extern "SDL_FreeSurface"
extern "SDL_GetError"
extern "SDL_LoadBMP_RW"
extern "SDL_Init"
extern "SDL_PollEvent"
extern "SDL_RenderClear"
extern "SDL_RenderCopy"
extern "SDL_RenderFillRect"
extern "SDL_RenderPresent"
extern "SDL_RWFromFile"
extern "SDL_SetRenderDrawColor"
extern "SDL_Quit"

struct SDLRect {
    x: i32,
    y: i32,
    width: i32,
    height: i32
}

asm sdlInit() /{
    ; SDL_Init(SDL_INIT_EVERYTHING)
    $ccall(SDL_Init, 62001)
}/

asm sdlCreateWindow(title: str, x: i32, y: i32, width: i32, height: i32) -> i32 /{
    $ccall(SDL_CreateWindow, $title, $x, $y, $width, $height, 4)
}/

asm sdlDelay(millis: i32) /{
    $ccall(SDL_Delay, $millis)
}/

asm sdlCreateRenderer(win: i32) -> i32 /{
    ; SDL_RENDERER_ACCELERATED = 0x00000002
    ; SDL_RENDERER_PRESENTVSYNC = 0x00000004
    $ccall(SDL_CreateRenderer, $win, -1, 6)
}/

asm sdlLoadBMP(file: str) -> i32 /{
    $ccall(SDL_RWFromFile, $file, "rb")
    $ccall(SDL_LoadBMP_RW, eax, 1)
}/

asm sdlCreateTextureFromSurface(ren: i32, bmp: i32) -> i32 /{
    $ccall(SDL_CreateTextureFromSurface, $ren, $bmp)
}/

asm sdlFreeSurface(bmp: i32) /{
    $ccall(SDL_FreeSurface, $bmp)
}/

asm sdlRenderClear(ren: i32) /{
    $ccall(SDL_RenderClear, $ren)
}/

asm sdlRenderCopy(ren: i32, tex: i32) /{
    $ccall(SDL_RenderCopy, $ren, $tex, 0, 0)
}/

asm sdlRenderPresent(ren: i32) /{
    $ccall(SDL_RenderPresent, $ren)
}/

asm sdlDestroyRenderer(ren: i32) /{
    $ccall(SDL_DestroyRenderer, $ren)
}/

asm sdlDestroyTexture(tex: i32) /{
    $ccall(SDL_DestroyTexture, $tex)
}/

asm sdlDestroyWindow(win: i32) /{
    $ccall(SDL_DestroyWindow, $win)
}/

asm sdlGetError() -> str /{
    $ccall(SDL_GetError)
    ; TODO I don't know if it works or if it is correct: it is not a static string
    $call(addStaticStringToHeap, eax)
}/

asm sdlQuit() /{
    $ccall(SDL_Quit)
}/

asm sdlSetRenderDrawColor(ren: i32, r: i32, g: i32, b: i32, a: i32) /{
    $ccall(SDL_SetRenderDrawColor, $ren, $r, $g, $b, $a)
}/

asm sdlRenderFillRect(ren: i32, rect: SDLRect) /{
    $ccall(SDL_RenderFillRect, $ren, $rect)
}/

enum KeyState {
    Down,
    Up
}

fn print(state: KeyState) {
    KeyState::run(state, { -> print("Down");}, { -> print("Up");});
}

struct KeyEvent {
    key: i32,
    state: KeyState
}

fn print(event: KeyEvent) {
    let key = KeyEvent::key(event);
    let state = KeyEvent::state(event);
    print("key=");
    print(key);
    print(" state=");
    print(state);
}

/*
SDL C types:

typedef union{
  Uint8 type;
  SDL_ActiveEvent active;
  SDL_KeyboardEvent key;
  SDL_MouseMotionEvent motion;
  SDL_MouseButtonEvent button;
  SDL_JoyAxisEvent jaxis;
  SDL_JoyBallEvent jball;
  SDL_JoyHatEvent jhat;
  SDL_JoyButtonEvent jbutton;
  SDL_ResizeEvent resize;
  SDL_ExposeEvent expose;
  SDL_QuitEvent quit;
  SDL_UserEvent user;
  SDL_SysWMEvent syswm;
} SDL_Event;

typedef struct{
  Uint8 type;
  Uint8 state;
  SDL_keysym keysym;
} SDL_KeyboardEvent;

typedef struct{
  Uint8 scancode;
  SDLKey sym;
  SDLMod mod;
  Uint16 unicode;
} SDL_keysym;

*/
asm keyEvent() -> Option<KeyEvent> /{
    push    ebx

    $call(malloc, 56)
    mov  dword  ebx, [eax]
    $ccall(SDL_PollEvent, [eax]);
    cmp     eax, 0
    je      .noKey
    mov     dword eax,[ebx] ; here we have the type
    cmp     eax, 768        ; keyDown
    jne     .noKeyDown
    $addRef(KeyState, [_enum_KeyState_Down]:KeyState)
    $call(KeyEvent, [ebx + 16], [_enum_KeyState_Down]:KeyState)
    $addRef(KeyEvent, eax)
    $call(Option::Some, eax: KeyEvent)
    jmp     .end
.noKeyDown:
    cmp     eax, 769        ; keyUp
    jne     .noKey
    $addRef(KeyState, [_enum_KeyState_Up]:KeyState)
    $call(KeyEvent, [ebx + 16], [_enum_KeyState_Up]:KeyState)
    $addRef(KeyEvent, eax)
    $call(Option::Some, eax: KeyEvent)
    jmp     .end
.noKey:
    mov     dword eax, [_enum_Option_None]
.end:
    pop     ebx
}/