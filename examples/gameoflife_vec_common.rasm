struct Cell {
    x: i32,
    y: i32
}

struct FullCell {
    cell: Cell,
    adjacents: Vec<Cell>
}

fn allCells(width: i32, height: i32) -> Vec<FullCell> {
    zip(vecRange(0, height), vecRange(0, width), { y, x ->
        let cell = Cell(x, y);

        FullCell(cell, adjacents(cell));
    });
}

fn moveCells(cells: Vec<Cell>, d: i32) -> Vec<Cell> {
    map(cells, { it -> Cell(add(Cell::x(it), d), add(Cell::y(it), d)); });
}

fn next(cells: Vec<Cell>, allCells: Vec<FullCell>) -> Vec<Cell> {
    let result = map(filter(allCells, { it ->
        let adjsAlive = count(FullCell::adjacents(it),  { a -> isAlive(cells, a); });
        let cell = FullCell::cell(it);
        ifImmediate(isAlive(cells, cell),
            or(eq(adjsAlive, 2),eq(adjsAlive,3)),
            eq(adjsAlive, 3)
        );
    }), { it -> FullCell::cell(it);});
    result;
}

fn adjacents(cell: Cell) -> Vec<Cell> {
    let x = Cell::x(cell);
    let y = Cell::y(cell);

    let left = add(x, -1);
    let right = add(x, 1);
    let up = add(y, -1);
    let down = add(y, 1);

    vecOf(
        Cell(left, up),
        Cell(left, y),
        Cell(left, down),
        Cell(x, up),
        Cell(x, down),
        Cell(right, up),
        Cell(right, y),
        Cell(right, down)
    );
}

/** false = 0 true = any other value **/
fn isAlive(cells: Vec<Cell>, cell: Cell) -> bool {
    let x = Cell::x(cell);
    let y = Cell::y(cell);

    vecAnyMatch(cells, { it ->
        and(eq(x, Cell::x(it)), eq(y, Cell::y(it)));
    });
}

fn readCellFile(file: str) -> Vec<Cell> {
    let linesEnumerate = listEnumerate(filterLines(lines(readFile(file))));

    let l = fmap(linesEnumerate, { line -> lineCells(line); });
    listToVec(l);
}

fn lineCells(line: EnumerateEntry<str>) -> List<Cell> {
    let y = EnumerateEntry::index(line);
    let lineStr = EnumerateEntry::value(line);

    map(filter(listEnumerate(chars(lineStr)), { cell ->
        let cellStr = EnumerateEntry::value(cell);

        List::match(chars(cellStr), { head, tail -> seq(head, "O"); }, { -> false;});
    }), { cell -> Cell(EnumerateEntry::index(cell), y); });
}

fn filterLines(lines: List<str>) -> List<str> {
    filter(lines, { line ->
        List::match(chars(line), { head, tail -> not(seq(head, "!")); }, { -> false;});
    });
}

fn printCellsPlain(cells: Vec<Cell>) {
    forEach(cells, { cell ->
        print(Cell::x(cell));
        print(",");
        print(Cell::y(cell));
        print(" ");
    });

    println();
}

fn printAllCellsPlain(cells: Vec<FullCell>) {
    forEach(cells, { fullCell ->
        let cell = FullCell::cell(fullCell);
        print(Cell::x(cell));
        print(",");
        print(Cell::y(cell));
        print(" ");
    });

    println();
}