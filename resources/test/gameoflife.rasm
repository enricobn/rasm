include "std.rasm"

struct Cell {
    x: i32,
    y: i32
}

run(moveCells(
        listOf7(
           Cell(7, 1),
           Cell(1, 2),
           Cell(2, 2),
           Cell(2, 3),
           Cell(6, 3),
           Cell(7, 3),
           Cell(8, 3)), 10)
        , 30, atoi(argv(1)));

fn run(start: List<Cell>, size: i32, count: i32) {
    printCells(
        listFoldL(range(0, count), start, { prev, act ->
            printCells(prev, size, size);
            moveUp(30);
            //sleep(0, 250000000);
            next(prev, size, size);
          }), size, size);
}

fn moveCells(cells: List<Cell>, d: i32) -> List<Cell> {
    listMap(cells, { it -> Cell(nadd(Cell::x(it), d), nadd(Cell::y(it), d)); });
}

fn printCells(cells: &List<&Cell>, width: i32, height: i32) {
    listMap(range(0, height), { y ->
        listMap(range(0, width), { x ->
            if(isAlive(cells, Cell(x, y)), { -> sprint("*"); }, { -> sprint(" "); });
        });
        sprintln("");
    });
}

fn allCells(width: i32, height: i32) -> List<Cell> {
    listFlatten(listMap(range(0, height), { y ->
        listMap(range(0, width), { x ->
            Cell(x, y);
        });
    }));
}

fn next(cells: &List<Cell>, width: i32, height: i32) -> List<Cell> {
    listFMap(allCells(width, height), { it ->
        with(listCount(adjacents(it),  { a -> isAlive(cells, a); }), { alive ->
            if(isAlive(cells, it), { ->
                if(less(alive, 2), { ->
                    List::Empty();
                }, { ->
                    if(less(alive, 4), { ->
                        listOf(it);
                    }, { ->
                        List::Empty();
                    });
                });
            }, { ->
                if(eq(alive, 3), { ->
                    listOf(it);
                }, { -> List::Empty(); });
            });
        });
    });
}

fn adjacents(cell: &Cell) -> List<Cell> {
    with2(Cell::x(cell), Cell::y(cell), { x, y ->
        listOf8(
            Cell(nadd(x, -1), nadd(y, -1)),
            Cell(nadd(x, -1), y),
            Cell(nadd(x, -1), nadd(y, 1)),
            Cell(x, nadd(y, 1)),
            Cell(x, nadd(y, -1)),
            Cell(nadd(x, 1), nadd(y, -1)),
            Cell(nadd(x, 1), y),
            Cell(nadd(x, 1), nadd(y, 1))
        );
    });
}

/** false = 0 true = any other value **/
fn isAlive(cells: &List<Cell>, cell: &Cell) -> i32 {
    listAnyMatch(cells, { it ->
        and(eq(Cell::x(cell), Cell::x(it)), eq(Cell::y(cell), Cell::y(it)));
    });
}