/**
 * Prints the string to standard output adding a line feed to the end.
 **/
fn sprintln(s: &str) {
    sprint(s);
    println();
}

/**
 * Prints the number to standard output adding a line feed to the end.
 **/
fn nprintln(n: i32) {
    nprint(n);
    println();
}

/**
 * Prints the number to standard output.
 * TODO it supports only 10 digits
 * https://stackoverflow.com/questions/25064565/printing-an-integer-with-x86-32-bit-linux-sys-write-nasm
 **/
asm nprint(n: i32) /{
    push    esi
    push    eax
    push    ebx
    push    ecx
    push    edx
    mov     eax,$n ; integer value to convert
    mov     esi,_rasm_buffer_10b
    add     esi,9
    mov     byte [esi],0    ; String terminator

    mov ebx,10
    xor ecx,ecx         ; initialize length
.next_digit:
    xor edx,edx         ; Clear edx prior to dividing edx:eax by ebx
    div ebx             ; eax /= 10
    add dl,'0'          ; Convert the remainder to ASCII
    dec esi             ; store characters in reverse order
    inc ecx             ; length

    mov [esi],dl
    test eax,eax
    jnz .next_digit     ; Repeat until eax==0

    mov    edx,ecx ; the length
    mov     ecx,esi ; the pointer to the first digit (not necessarily the start of the provided buffer)
    mov     ebx, 1  ; stdout
    mov     eax, 4  ; write
    int     80h

    pop    edx
    pop    ecx
    pop    ebx
    pop    eax
    pop    esi
}/

/**
 * Prints a new line to standard output.
 */
asm println() /{
    mov     eax, 0Ah    ; move 0Ah into eax - 0Ah is the ascii character for a linefeed
    push    eax         ; push the linefeed onto the stack so we can get the address
    push    esp         ; push the address of the current stack pointer where is the \n char for sprint
    call    sprint      ; call our sprint function
    pop     eax         ; remove the linefeed char from the stack
    pop     eax
}/

/**
 * Prints the string to the standard output.
 **/
asm sprint(s: &str) /{
    push    edx
    push    ecx
    push    ebx
    push    eax
    mov     eax,$s
    push    eax
    call    slen

    mov     edx, eax
    pop     eax

    mov     ecx, eax
    mov     ebx, 1
    mov     eax, 4
    int     80h

    pop     eax
    pop     ebx
    pop     ecx
    pop     edx
}/

// https://man7.org/linux/man-pages/man4/console_codes.4.html
fn moveUp(count: i32) {
    printESC();
    sprint("[");
    nprint(count);
    sprint("A");
}

fn printESC() /{
    push    eax
    push    ebx
    push    ecx
    push    edx
    mov     edx, 1 ; num of chars
    mov     ecx, _ESC
    mov     ebx, 1
    mov     eax, 4
    int     80h
    add     esp, 16
}/

/** Returns the length of the string **/
asm slen(s: &str) -> i32 /{
    push    ebx             ; Save ebx to the stack since we use it
    mov     eax, $s         ; Get the parameter from the stack (4 the PC + 4 ebp) and put it in eax
    mov     ebx, eax

.nextchar:
    cmp     byte [eax], 0
    jz      .finished
    inc     eax
    jmp     .nextchar

.finished:
    sub     eax, ebx
    pop     ebx
}/

/** Adds two numbers **/
inline asm nadd(n1: i32, n2: i32) -> i32 /{
    mov     eax, $n1
    add     eax, $n2
}/

/** false = 0 true = any other value **/
asm if(cond: i32, ftrue: fn() -> (), ffalse: fn() -> ()) -> i32 /{
    push    ebx
    mov     eax,$cond
    cmp     eax, 0
    jz      $+13
    mov     ebx, $ftrue     ; ftrue points to the lambda space
    push    ebx             ; the address to the lambda space is the last argument of every lambda
    call    [ebx]           ; in the first 4 bytes of the lambda space there is the address of the lambda function to call
    add     esp, 4
    jmp     $+11
    mov     ebx, $ffalse    ; ffalse points to the lambda space
    push    ebx
    call    [ebx]           ; false value
    add     esp, 4
    pop ebx
}/

/** TODO it should be a bool
 *  a  <= b
 *  false = 0 true = any other value
 **/
inline asm lessOrEqual(a: i32, b: i32) -> i32 /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    jbe     $+7  ; Jump if Below or Equal (unsigned comparison)
    mov     eax,0 ; false
}/

/** TODO it should be a bool
 *  a  < b
 *  false = 0 true = any other value
 **/
inline asm less(a: i32, b: i32) -> i32 /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    jb     $+7  ; Jump if Below or Equal (unsigned comparison)
    mov     eax,0 ; false
}/

/** TODO it should be a bool
 *  a  <= b
 *  false = 0 true = any other value
 **/
inline asm greater(a: i32, b: i32) -> i32 /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    jg      $+7  ; Jump if greater (unsigned comparison)
    mov     eax,0 ; false
}/

/** TODO it should be a bool
 *  a  == b
 *  false = 0 true = any other value
 **/
inline asm eq(a: i32, b: i32) -> i32 /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    je      $+7  ; Jump if equals
    mov     eax,0 ; false
}/

asm exit(status: i32) /{
    mov     ebx, $status    ; Arg one: the status
    mov     eax, 1          ; Syscall number:
    int     0x80
}/

fn assert(value: i32) {
    if(value,{ -> },{ ->
        sprintln("assertion failed");
        exit(1);
    });
}

fn assertFalse(value: i32) {
    if(value,{ ->
        sprintln("assertion failed");
        exit(1);
    }, { -> });
}

asm argc() -> i32 /{
    mov     eax,[_rasm_args]
}/

// TODO unsafe
asm argv(i: i32) -> i32 /{
    push ebx
    push ecx
    mov ebx, _rasm_args
    mov ecx,4           ; i add 4*i to the base address (_rasm_args)
    mov eax,$i
    inc eax             ; we skip the length (argc)
    mul ecx
    add ebx,eax
    mov eax,[ebx]
    pop ecx
    pop ebx
}/

/**
 * parse a string to a number
 from https://stackoverflow.com/questions/19461476/convert-string-to-int-x86-32-bit-assembler-using-nasm
 **/
asm atoi(s: &str) -> i32 /{
    push    ecx
    push    edx
    mov edx, $s ; our string
    xor eax, eax ; zero a "result so far"
    .top:
    movzx ecx, byte [edx] ; get a character
    inc edx ; ready for next one
    cmp ecx, '0' ; valid?
    jb .done
    cmp ecx, '9'
    ja .done
    sub ecx, '0' ; "convert" character to number
    imul eax, 10 ; multiply "result so far" by ten
    add eax, ecx ; add in current digit
    jmp .top ; until done
.done:
    pop    edx
    pop    ecx
}/

asm lambdaSpaceMalloc(size: i32) -> i32 /{
    mov     eax,[_lambda_space_heap]
    add     eax,$size
    mov     dword [_lambda_space_heap],eax
    sub     eax,$size
}/

asm lambdaSpaceMdealloc(size: i32) /{
    push    eax
    mov     eax,[_lambda_space_heap]
    sub     eax,$size
    mov     dword [_lambda_space_heap],eax
    pop     eax
}/

/* mem is the pointer to a location in memory where is stored the next available memory location */
asm malloc(mem: &i32, size: i32) -> i32 /{
    push    ebx
    mov     eax,$mem            ; we store in eax the pointer
    push    dword [eax]         ; we save in the stack the actual next memory location that we must return (in eax)
    mov     dword ebx,[eax]
    add     ebx,$size
    mov     dword [eax],ebx
    pop     eax                 ; we restore from the stack the saved memory location
    pop     ebx
}/

asm mdealloc(mem: &i32, size: i32) /{
    push    ebx
    push    eax
    mov     eax,$mem
    mov     dword ebx,[eax]
    sub     ebx,$size
    mov     dword [eax],ebx
    pop     eax
    pop     ebx
}/

asm memcopy(source: &i32, dest: &i32, len: i32) /{
    push    eax
    push    ebx
    push    ecx
    push    edx
    mov     eax, $source
    mov     ebx, $dest
    mov     ecx, $len
.loop:
    cmp     ecx, 0
    jz      .end
    mov     dword edx,[eax]
    mov     dword [ebx],edx
    add     ebx,4
    add     eax,4
    sub     ecx,1
    jmp     .loop
.end:
    pop     edx
    pop     ecx
    pop     ebx
    pop     eax
}/

// from https://stackoverflow.com/questions/19580282/nasm-assembly-linux-timer-or-sleep
fn sleep(sec: i32, nsec: i32) -> i32 /{
    push ebx
    push ecx
    mov dword eax,$sec
    mov dword [tv_sec], eax
    mov dword eax,$nsec
    mov dword [tv_usec], eax
    mov eax, 162
    mov ebx, timeval
    mov ecx, 0
    int 0x80
    pop ecx
    pop ebx
}/

fn or(a: i32, b: i32) -> i32 {
    if(a, { -> itn(1);}, { -> b; });
}

fn and(a: i32, b: i32) -> i32 {
    if(a, { -> b;}, { -> a; });
}

fn not(b: i32) -> i32 {
    if(b, { -> itn(0);}, { -> itn(1); });
}

// TODO get rid of this, for now is used to return constants
fn itn(n: i32) -> i32 {
    $n;
}

/*  OPTION */
enum Option<T> {
  Some(value : T),
  None
}

/*  LIST */

enum List<T> {
  Full(head: T, tail: List<T>),
  Empty
}

fn nListPrintln(l: List<i32>) {
    nListPrint(l);
    sprintln("");
}

fn nListPrint(l: List<i32>) {
    ListMatch(l, { head,tail -> nprint(head); ListMatch(tail, { head1,tail1 -> sprint(",");}, { -> }); nListPrint(tail);}, { -> });
}

fn range(start: i32, end: i32) -> List<i32> {
    if (less(start, end), { ->
        List::Full(start, range(nadd(start, 1), end));
    }, { ->
        List::Empty();
    });
}

fn listMap(l: List<T>, map: fn(T) -> T) -> List<T> {
    ListMatch(l, { head,tail -> List::Full(map(head), listMap(tail, map)); }, { -> List::Empty();});
}

/** false = 0 true = any other value **/
fn listAnyMatch(l: &List<T>, predicate: fn(T) -> i32) -> i32 {
    ListMatch(l, { head,tail -> if(predicate(head), { -> itn(1); }, { -> listAnyMatch(tail, predicate); }); }, { -> itn(0); });
}

fn listCount(l: &List<T>, predicate: fn(T) -> i32) -> i32 {
    ListMatch(l, { head,tail -> nadd(listCount(tail, predicate), if(predicate(head), { -> itn(1); }, { -> itn(0); })); }, { -> itn(0); });
}

fn listAdd(l: &List<T>, value: T) -> List<T> {
    List::Full(value, l);
}

fn listOf(v: T) -> List<T> {
    List::Full(v, List::Empty());
}

fn listOf2(v1: T, v2: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Empty()));
}

fn listOf3(v1: T, v2: T, v3: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Full(v3, List::Empty())));
}

fn listOf4(v1: T, v2: T, v3: T, v4: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Full(v3, List::Full(v4, List::Empty()))));
}

fn listOf5(v1: T, v2: T, v3: T, v4: T, v5: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Full(v3, List::Full(v4, List::Full(v5, List::Empty())))));
}

fn listOf6(v1: T, v2: T, v3: T, v4: T, v5: T, v6: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Full(v3, List::Full(v4, List::Full(v5, List::Full(v6, List::Empty()))))));
}

fn listOf7(v1: T, v2: T, v3: T, v4: T, v5: T, v6: T, v7: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Full(v3, List::Full(v4, List::Full(v5, List::Full(v6, List::Full(v7, List::Empty())))))));
}

fn listOf8(v1: T, v2: T, v3: T, v4: T, v5: T, v6: T, v7: T, v8: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Full(v3, List::Full(v4, List::Full(v5, List::Full(v6, List::Full(v7, List::Full(v8, List::Empty()))))))));
}

fn listPrintln(l: List<T>, print: fn(T) -> ()) {
    listPrint(l, print);
    sprintln("");
}

fn listPrint(l: List<T>, printFunction: fn(T) -> ()) {
    ListMatch(l, { head,tail ->
        printFunction(head);
        ListMatch(tail, { head1,tail1 -> sprint(","); }, { -> });
        listPrint(tail, printFunction);
    }, { -> });
}

fn listFMap(l: List<T>, map: fn(T) -> List<T>) -> List<T> {
    listFlatten(listMap(l, map));
}

fn listFlatten(l: List<List<T>>) -> List<T> {
    ListMatch(l, { head, tail ->
        listAppend(head, listFlatten(tail));
    },
    { -> List::Empty(); });
}

fn listAppend(dest: List<T>, source: List<T>) -> List<T> {
    ListMatch(dest, { head,tail -> List::Full(head, listAppend(tail, source)); }, { -> source;});
}

fn listFoldL(l: List<T>, zero: T1, accum: fn(T1,T) -> T1) -> T1 {
    ListMatch(l, { head, tail ->
         listFoldL(tail, accum(zero, head), accum);
    }, { -> zero; });
}

fn listFoldR(l: List<T>, zero: T1, accum: fn(T1,T) -> T1) -> T1 {
    listFoldL(listReverse(l), zero, accum);
}

fn listReverse(l: List<T>) -> List<T> {
    ListMatch(l, { head1, tail1 ->
        listAppend(listReverse(tail1), listOf(head1));
    }, { -> List::Empty(); });
}

