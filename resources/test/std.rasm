inline asm itn(n: i32) -> i32[eax] /{
    mov     eax,$n
}/

/**
 * Prints the string to standard output adding a line feed to the end.
 **/
fn sprintln(s: &str) {
    sprint(s);
    println();
}

/**
 * Prints the number to standard output adding a line feed to the end.
 **/
fn nprintln(n: i32) {
    nprint(n);
    println();
}

/**
 * Prints the number to standard output.
 * TODO it supports only 10 digits
 * https://stackoverflow.com/questions/25064565/printing-an-integer-with-x86-32-bit-linux-sys-write-nasm
 **/
asm nprint(n: i32) /{
  push    esi
  push    eax
  push    ebx
  push    ecx
  push    edx
  mov     eax,$n ; integer value to convert
  mov     esi,_rasm_buffer_10b
  add     esi,9
  mov     byte [esi],0    ; String terminator

  mov ebx,10
  xor ecx,ecx         ; initialize length
.next_digit:
  xor edx,edx         ; Clear edx prior to dividing edx:eax by ebx
  div ebx             ; eax /= 10
  add dl,'0'          ; Convert the remainder to ASCII
  dec esi             ; store characters in reverse order
  inc ecx             ; length

  mov [esi],dl
  test eax,eax
  jnz .next_digit     ; Repeat until eax==0

  mov    edx,ecx ; the length
  mov     ecx,esi ; the pointer to the first digit (not necessarily the start of the provided buffer)
  mov     ebx, 1  ; stdout
  mov     eax, 4  ; write
  int     80h

  pop    edx
  pop    ecx
  pop    ebx
  pop    eax
  pop    esi
}/

/**
 * Prints a new line to standard output.
 */
asm println() /{
    mov     eax, 0Ah    ; move 0Ah into eax - 0Ah is the ascii character for a linefeed
    push    eax         ; push the linefeed onto the stack so we can get the address
    push    esp         ; push the address of the current stack pointer where is the \n char for sprint
    call    sprint      ; call our sprint function
    pop     eax         ; remove the linefeed char from the stack
    pop     eax
}/

/**
 * Prints the string to the standard output.
 **/
asm sprint(s: &str) /{
    push    edx
    push    ecx
    push    ebx
    push    eax
    mov     eax,$s
    push    eax
    call    slen

    mov     edx, eax
    pop     eax

    mov     ecx, eax
    mov     ebx, 1
    mov     eax, 4
    int     80h

    pop     eax
    pop     ebx
    pop     ecx
    pop     edx
}/

/** Returns the length of the string **/
asm slen(s: &str) -> i32[eax] /{
    push    ebx             ; Save ebx to the stack since we use it
    mov     eax, $s  ; Get the parameter from the stack (4 the PC + 4 ebp) and put it in eax
    mov     ebx, eax

.nextchar:
    cmp     byte [eax], 0
    jz      .finished
    inc     eax
    jmp     .nextchar

.finished:
    sub     eax, ebx
    pop     ebx
}/

/** Adds two numbers **/
inline asm nadd(n1: i32, n2: i32) -> i32[eax] /{
    mov     eax, $n1
    add     eax, $n2
}/

/** false = 0 true = any other value **/
inline asm if(cond: i32, ftrue: fn, ffalse: fn) -> i32[eax] /{
    mov     eax,$cond
    cmp     eax, 0
    jz      $+7
    call    $ftrue ; true value
    jmp     $+5
    call    $ffalse ; false value
}/

/** TODO it should be a bool
 *  a  <= b
 *  false = 0 true = any other value
 **/
inline asm lessOrEqual(a: i32, b: i32) -> i32[eax] /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    jbe     $+7  ; Jump if Below or Equal (unsigned comparison)
    mov     eax,0 ; false
}/

/** TODO it should be a bool
 *  a  < b
 *  false = 0 true = any other value
 **/
inline asm less(a: i32, b: i32) -> i32[eax] /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    jb     $+7  ; Jump if Below or Equal (unsigned comparison)
    mov     eax,0 ; false
}/

/** TODO it should be a bool
 *  a  <= b
 *  false = 0 true = any other value
 **/
inline asm greater(a: i32, b: i32) -> i32[eax] /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    jg      $+7  ; Jump if greater (unsigned comparison)
    mov     eax,0 ; false
}/

/** TODO it should be a bool
 *  a  == b
 *  false = 0 true = any other value
 **/
inline asm eq(a: i32, b: i32) -> i32[eax] /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    je      $+7  ; Jump if equals
    mov     eax,0 ; false
}/

asm exit(status: i32) /{
    mov     ebx, $status    ; Arg one: the status
    mov     eax, 1          ; Syscall number:
    int     0x80
}/

fn assert(value: i32) {
    if(value,{},{
        sprintln("assertion failed");
        exit(1);
    });
}

asm argc() -> i32[eax] /{
    mov     eax,[_rasm_args]
}/

// TODO unsafe
asm argv(i: i32) -> i32[eax] /{
    push ebx
    push ecx
    mov ebx, _rasm_args
    mov ecx,4           ; i add 4*i to the base address (_rasm_args)
    mov eax,$i
    inc eax             ; we skip the length (argc)
    mul ecx
    add ebx,eax
    mov eax,[ebx]
    pop ecx
    pop ebx
}/

/**
 * parse a string to a number
 from https://stackoverflow.com/questions/19461476/convert-string-to-int-x86-32-bit-assembler-using-nasm
 **/
asm atoi(s: &str) -> i32[eax] /{
    push    ecx
    push    edx
    mov edx, $s ; our string
    xor eax, eax ; zero a "result so far"
    .top:
    movzx ecx, byte [edx] ; get a character
    inc edx ; ready for next one
    cmp ecx, '0' ; valid?
    jb .done
    cmp ecx, '9'
    ja .done
    sub ecx, '0' ; "convert" character to number
    imul eax, 10 ; multiply "result so far" by ten
    add eax, ecx ; add in current digit
    jmp .top ; until done
.done:
    pop    edx
    pop    ecx
}/