print();

fn print() {
  if(0,{sprintln("True");},{sprintln("False");});
}

/**
 * Prints the string to standard output adding a line feed to the end.
 **/
fn sprintln(s: &str) {
    sprint(s);
    println();
}

/**
 * Prints a new line to standard output.
 */
asm println() /{
    mov     eax, 0Ah    ; move 0Ah into eax - 0Ah is the ascii character for a linefeed
    push    eax         ; push the linefeed onto the stack so we can get the address
    push    esp         ; push the address of the current stack pointer where is the \n char for sprint
    call    sprint      ; call our sprint function
    pop     eax         ; remove the linefeed char from the stack
    pop     eax
}/

/**
 * Prints the string to the standard output.
 **/
asm sprint(s: &str) /{
    push    edx
    push    ecx
    push    ebx
    push    eax
    mov     eax,[ebp+4+4]
    push    eax
    call    slen

    mov     edx, eax
    pop     eax

    mov     ecx, eax
    mov     ebx, 1
    mov     eax, 4
    int     80h

    pop     eax
    pop     ebx
    pop     ecx
    pop     edx
}/

/** Returns the length of the string **/
asm slen(s: &str) -> i32[eax] /{
    push    ebx             ; Save ebx to the stack since we use it
    mov     eax, [ebp+4+4]  ; Get the parameter from the stack (4 the PC + 4 ebp) and put it in eax
    mov     ebx, eax

.nextchar:
    cmp     byte [eax], 0
    jz      .finished
    inc     eax
    jmp     .nextchar

.finished:
    sub     eax, ebx
    pop     ebx
}/


/** false = 0 true = any other value **/
asm if(cond: i32, ftrue: fn, ffalse: fn) -> i32[eax] /{
    cmp     word [ebp+4+4], 0
    jz     .falseValue
    call     [ebp+4+8] ; true value
    jmp      .finished
.falseValue:
    call     [ebp+4+12] ; false value
.finished:
}/