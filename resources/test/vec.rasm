include "std.rasm"

type Vec<T>;

let v = vecRange(0, 2);
nVecPrintln(v);

let m = vecMap(v, { n -> nadd(n, 10);});
nVecPrintln(m);

ifRun(vecAnyMatch(v, { n -> eq(n, 0);}), { -> sprintln("true");}, { -> sprintln("false");});
ifRun(vecAnyMatch(v, { n -> eq(n, 2);}), { -> sprintln("true");}, { -> sprintln("false");});

ifRun(vecAnyMatch(vecRange(0, 2), { n -> eq(n, 0);}), { -> sprintln("true");}, { -> sprintln("false");});
ifRun(vecAnyMatch(vecRange(0, 2), { n -> eq(n, 2);}), { -> sprintln("true");}, { -> sprintln("false");});

nprintln(vecCount(vecRange(0, 10), { n -> eq(n, 5);}));
nprintln(vecCount(vecRange(0, 10), { n -> lessOrEqual(n, 5);}));
nprintln(vecCount(vecRange(0, 10), { n -> lessOrEqual(n, 1);}));

fn nVecPrintln(v: Vec<i32>) {
    vecForeach(v, { n -> nprint(n); sprint(",");});
    println();
}

asm vecOf<T>(value: T) -> Vec<T> /{
    $call(malloc, 8)
    push    eax
    mov     dword eax, [eax]
    mov     dword [eax], 1
    add     eax, 4
    push    ebx
    mov     dword ebx, $value
    mov     dword [eax], ebx
    pop     ebx
    pop     eax
}/

asm vecForeach<T>(vec: Vec<T>, f: fn(T) -> ()) /{
    push    ebx
    push    ecx
    push    edx
    mov     dword ebx, $vec
    mov     dword ebx, [ebx]
    mov     dword ecx, [ebx]    ; count
    add     ebx, 4  ; address of first value
    mov     edx, $f         ; points to the lambda space
.loop:
    cmp     dword ecx, 0
    jz      .end
    push    dword [ebx]
    push    edx             ; the address to the lambda space is the last argument of every lambda
    call    [edx]           ; in the first 4 bytes of the lambda space there is the address of the lambda function to call
    add     esp, 8
    add     ebx, 4
    dec     ecx
    jmp     .loop

.end:
    pop     edx
    pop     ecx
    pop     ebx
}/

// end exclusive
asm vecRange(start: i32, end: i32) -> Vec<i32> /{
    push    ebx
    push    ecx
    push    edx

    mov     dword ebx, $end
    sub     dword ebx, $start
    push    ebx                 ; the size
    inc     ebx                 ; + 1 for the size
    add     ebx, ebx
    add     ebx, ebx
    $call(malloc, ebx)
    pop     ebx
    push    eax
    mov     dword ecx, [eax]
    mov     dword [ecx], ebx    ; the size
    add     ecx, 4              ; the pointer to the next value
    mov     dword edx, 0        ; the actual value
.loop:
    cmp     dword ebx, 0
    jz      .end
    mov     dword [ecx], edx

    add     ecx, 4
    dec     ebx
    inc     edx
    jmp     .loop
.end:
    pop     eax
    ; $call(sprint, "vecRange ")
    ; $call(nprintln, eax)
    pop     edx
    pop     ecx
    pop     ebx
}/

asm vecMap<T,T1>(vec: Vec<T>, f: fn(T) -> T1) -> Vec<T1>/{
    push    ebx
    push    ecx
    push    edx

    mov     dword ebx, $vec
    mov     dword ebx, [ebx]    ; the address of the allocated memory
    mov     dword ecx, [ebx]    ; size
    push    ecx
    inc     ecx                 ; + 1 for the size
    add     ecx, ecx
    add     ecx, ecx
    $call(malloc, ecx)
    pop     ecx
    push    eax
    mov     dword eax, [eax]
    mov     dword [eax], ecx
    mov     edx, eax
    add     edx, 4          ; address of first value to write
    add     ebx, 4          ; address of first value to read
.loop:
    cmp     dword ecx, 0
    jz      .end
    push    dword [ebx]
    push    dword $f
    mov     dword eax, $f
    call    [eax]
    add     esp, 8
    mov     dword [edx], eax
    add     ebx, 4
    add     edx, 4
    dec     ecx
    jmp .loop
.end:
    pop     eax
    pop     edx
    pop     ecx
    pop     ebx
}/

/** false = 0 true = any other value **/
asm vecAnyMatch<T>(vec: Vec<T>, f: fn(T) -> i32) -> i32 /{
    ; $call(sprint, "vecAnyMatch ")
    ; $call(nprintln, $vec)

    push    ebx
    push    ecx

    mov     dword ebx, $vec
    mov     dword ebx, [ebx]    ; the address of the allocated memory
    mov     dword ecx, [ebx]    ; size
    add     ebx, 4              ; the address of the first value
.loop:
    cmp     dword ecx, 0
    jz      .false
    ; $call(sprint, "  n ")
    ; $call(nprint, [ebx])
    push    dword [ebx]
    push    dword $f
    mov     dword eax, $f
    call    [eax]
    ; $call(sprint, " = ")
    ; $call(nprintln, eax)
    add     esp, 8
    cmp     dword eax, 0
    jnz      .true
    add     ebx, 4
    dec     ecx
    jmp     .loop
.false:
    mov     dword eax, 0
    jmp     .end
.true:
    mov     dword eax, 1
.end:
    ; $call(sprint, "  result = ")
    ; $call(nprintln, eax)
    pop     ecx
    pop     ebx
}/

asm vecCount<T>(vec: Vec<T>, f: fn(T) -> i32) -> i32 /{
    ; $call(sprintln, "vecCount")
    push    ebx
    push    ecx
    push    edx

    mov     dword ebx, $vec
    mov     dword ebx, [ebx]    ; the address of the allocated memory
    mov     dword ecx, [ebx]    ; size
    add     ebx, 4              ; the address of the first value
    mov     dword edx, 0        ; result
.loop:
    cmp     dword ecx, 0
    jz      .end
    push    dword [ebx]
    push    dword $f
    mov     dword eax, $f
    call    [eax]
    add     esp, 8
    cmp     dword eax, 0
    jz      .false
    inc     edx
.false:
    add     ebx, 4
    dec     ecx
    jmp     .loop
.end:
    mov     dword eax, edx
    pop     edx
    pop     ecx
    pop     ebx
}/

// TODO I think it cannot be used, since we cannot determine the type of T
asm Vec<T>() -> Vec<T> /{
    $call(malloc, 4)
    push    eax
    mov     dword eax, [eax]
    mov     dword [eax], 0
    pop     eax
}/