include "std.rasm"
include "../sdl.rasm"

include "game.rasm"
include "menu.rasm"

struct Resources {
    font: SDLFont
}

struct State {
    resources: Resources,
    keys: Vec<i32>,
    stage: Stage
}

enum Stage {
    Menu(menuState: MenuState),
    Game(gameState: GameState)
}

const WIDTH = 1024;
const HEIGHT = 768;
const BRICKWIDTH = 34;
const BRICKHEIGHT = 10;
const BARWIDTH = 50;
const BARHEIGHT = 10;
const HEADERHEIGHT = 25;
const BALLSIZE = 5;
const BLACK = SDLColor(0, 0, 0, 255);
const WHITE = SDLColor(255, 255, 255, 255);
const RED = SDLColor(255, 0, 0, 255);
const GREEN = SDLColor(0, 255, 0, 255);
const BLUE = SDLColor(0, 0, 255, 255);

sdlInit();
sdlTTFInit();

let font = sdlOpenFont("resources/examples/breakout/DejaVuSerif.ttf", 24);

let initialState = State(Resources(font), Vec(), Stage::Game(GameState(GameStage::Run(), initialWorld())));

let win = sdlErrorIfNull(sdlCreateWindow("Breakout", 100, 100, WIDTH, HEIGHT), "SDL_CreateWindow Error: %s\n");
let ren = sdlErrorIfNull(sdlCreateRenderer(win), "SDL_CreateRenderer Error: %s\n");

sdlLoop(ren, initialState,
    { event, state -> update(event, state);},
    { sdlRen, state -> render(sdlRen, state);}
);

sdlDestroyRenderer(ren);
sdlDestroyWindow(win);

fn update(event: Option<KeyEvent>, state: State) -> State {
    let resources = State::resources(state);
    let keys = State::keys(state);
    let stage = State::stage(state);

    let newKeys = Option::match(event, { e ->
          let key = KeyEvent::key(e);
          let keyState = KeyEvent::state(e);

          KeyState::match(keyState, { ->
            vecOf(key);
          }, { ->
            filter(keys, { k -> not(eq(k, key));});
          });
      }, { -> keys; });

    Stage::match(stage, { menuState -> state;}, { gameState ->
        let newGameState = update(resources, newKeys, gameState);
        State(resources, newKeys, Stage::Game(newGameState));
    });
}

fn render(ren: SDLRenderer, state: State) {
    let resources = State::resources(state);
    let keys = State::keys(state);
    let stage = State::stage(state);

    Stage::run(stage, { menuState -> }, { gameState -> render(ren, resources, gameState);});
}

fn println<T>(prefix: str, o: T) {
    print(prefix);
    println(o);
}

fn eq(b1: Brick, b2: Brick) -> bool {
    let b1x = Brick::x(b1);
    let b1y = Brick::y(b1);

    let b2x = Brick::x(b2);
    let b2y = Brick::y(b2);

    and(eq(b1x, b2x), eq(b1y, b2y));
}

fn collision(bricks: Vec<Brick>, ball: Ball) -> Option<Brick> {
    let x = Ball::x(ball);
    let y = Ball::y(ball);

    first(filter(bricks, { brick -> collides(x, y, brick); }));
}

fn collides(x: i32, y: i32, brick: Brick) -> bool {
    let bx = Brick::x(brick);
    let by = Brick::y(brick);

    let xColl = and(greater(add(x, BALLSIZE), bx), less(x, add(bx, BRICKWIDTH)));
    let yColl = and(greater(add(y, BALLSIZE), by), less(y, add(by, BRICKHEIGHT)));

    and(xColl, yColl);
}

fn collides(x: i32, y: i32, barPos: i32) -> bool {
    let bx = barPos;
    let by = sub(HEIGHT, BARHEIGHT);

    let xColl = and(greater(add(x, BALLSIZE), bx), less(x, add(bx, BARWIDTH)));
    let yColl = greater(add(y, BALLSIZE), by);

    and(xColl, yColl);
}

fn ballAfterCollision(ball: Ball, brick: Brick) -> Ball {
    let ballX = Ball::x(ball);
    let ballY = Ball::y(ball);
    let xDir = Ball::xDir(ball);
    let yDir = Ball::yDir(ball);
    let lastUpdate = Ball::lastUpdate(ball);

    let brickX = Brick::x(brick);
    let brickY = Brick::y(brick);

    let xDiff1 = sub(ballX, brickX);
    let xDiff2 = sub(add(brickX, BRICKWIDTH), ballX);
    let yDiff1 = sub(ballY, brickY);
    let yDiff2 = sub(add(brickY, BRICKHEIGHT), ballY);

    let xDiff = min(xDiff1, xDiff2);
    let yDiff = min(yDiff1, yDiff2);

    if(less(xDiff, yDiff), { -> Ball(ballX, ballY, flip(xDir), yDir, lastUpdate);}, { -> Ball(ballX, ballY, xDir, flip(yDir), lastUpdate);});
}

fn min(a: i32, b: i32) -> i32 {
    ifImmediate(less(a, b), a, b);
}

fn flip(xDir: XDirection) -> XDirection {
    XDirection::match(xDir, { -> XDirection::Right();}, { -> XDirection::Left(); } );
}

fn flip(yDir: YDirection) -> YDirection {
    YDirection::match(yDir, { -> YDirection::Down();}, { -> YDirection::Up(); } );
}