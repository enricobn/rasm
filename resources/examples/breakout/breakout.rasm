include "std.rasm"
include "../sdl.rasm"

include "game.rasm"
include "menu.rasm"

struct Resources {
    font: SDLFont
}

struct State {
    resources: Resources,
    keys: Vec<i32>,
    stage: Stage
}

enum Stage {
    Menu(menuState: MenuState),
    Game(gameState: GameState)
}

const WIDTH = 1024;
const HEIGHT = 768;
const BRICKWIDTH = 34;
const BRICKHEIGHT = 10;
const BARWIDTH = 50;
const BARHEIGHT = 10;
const HEADERHEIGHT = 25;
const BALLSIZE = 5;
const BLACK = SDLColor(0, 0, 0, 255);
const WHITE = SDLColor(255, 255, 255, 255);
const RED = SDLColor(255, 0, 0, 255);
const GREEN = SDLColor(0, 255, 0, 255);
const BLUE = SDLColor(0, 0, 255, 255);

sdlInit();
sdlTTFInit();

let font = sdlOpenFont("resources/examples/breakout/DejaVuSerif.ttf", 24);

let initialState = State(Resources(font), Vec(), Stage::Menu(MenuState(0)));

let win = sdlErrorIfNull(sdlCreateWindow("Breakout", 100, 100, WIDTH, HEIGHT), "SDL_CreateWindow Error: %s\n");
let ren = sdlErrorIfNull(sdlCreateRenderer(win), "SDL_CreateRenderer Error: %s\n");

sdlLoop(ren, initialState,
    { event, state -> update(event, state);},
    { sdlRen, state -> render(sdlRen, state);}
);

sdlDestroyRenderer(ren);
sdlDestroyWindow(win);

fn update(event: Option<KeyEvent>, state: State) -> State {
    let resources = State::resources(state);
    let keys = State::keys(state);
    let stage = State::stage(state);

    let newKeys = Option::match(event, { e ->
          let key = KeyEvent::key(e);
          let keyState = KeyEvent::state(e);

          KeyState::match(keyState, { ->
            vecOf(key);
          }, { ->
            filter(keys, { k -> not(eq(k, key));});
          });
      }, { -> keys; });

    Stage::match(stage, { menuState ->
        let newStage = update(resources, newKeys, menuState);
        State(resources, newKeys, newStage);
    }, { gameState ->
        let newStage = update(resources, newKeys, gameState);
        State(resources, newKeys, newStage);
    });
}

fn render(ren: SDLRenderer, state: State) {
    sdlSetRenderDrawColor(ren, BLACK);
    sdlRenderClear(ren);

    let resources = State::resources(state);
    let stage = State::stage(state);

    Stage::run(stage, { menuState -> render(ren, resources, menuState);}, { gameState -> render(ren, resources, gameState);});

    sdlRenderPresent(ren);
}

fn println<T>(prefix: str, o: T) {
    print(prefix);
    println(o);
}