include "std.rasm"
include "../sdl.rasm"

include "game.rasm"
include "menu.rasm"

enum GameResult {
    Play(state: GameState),
    End(score: i32)
}

struct Resources {
    font: SDLFont
}

struct HighScore {
    score: i32,
    time: TimeVal
}

struct State {
    resources: Resources,
    keys: Vec<i32>,
    stage: Stage,
    highScores: Vec<HighScore>
}

enum Stage {
    Menu(menuState: MenuState),
    Game(gameState: GameState)
}

const WIDTH = 1024;
const HEIGHT = 768;
const BRICKWIDTH = 34;
const BRICKHEIGHT = 10;
const BARWIDTH = 50;
const BARHEIGHT = 10;
const HEADERHEIGHT = 25;
const BALLSIZE = 5;
const BLACK = SDLColor(0, 0, 0, 255);
const WHITE = SDLColor(255, 255, 255, 255);
const RED = SDLColor(255, 0, 0, 255);
const GREEN = SDLColor(0, 255, 0, 255);
const BLUE = SDLColor(0, 0, 255, 255);

sdlInit();
sdlTTFInit();

let font = sdlOpenFont("resources/examples/breakout/DejaVuSerif.ttf", 24);

let initialState = State(Resources(font), Vec(), Stage::Menu(MenuState(0)), loadHighScores());

let win = sdlErrorIfNull(sdlCreateWindow("Breakout", 100, 100, WIDTH, HEIGHT), "SDL_CreateWindow Error: %s\n");
let ren = sdlErrorIfNull(sdlCreateRenderer(win), "SDL_CreateRenderer Error: %s\n");

sdlLoop(ren, initialState,
    { event, state -> update(event, state);},
    { sdlRen, state -> render(sdlRen, state);}
);

sdlDestroyRenderer(ren);
sdlDestroyWindow(win);

fn update(event: Option<KeyEvent>, state: State) -> State {
    let resources = State::resources(state);
    let keys = State::keys(state);
    let stage = State::stage(state);
    let highScores = State::highScores(state);

    let newKeys = Option::match(event, { e ->
          let key = KeyEvent::key(e);
          let keyState = KeyEvent::state(e);

          KeyState::match(keyState, { ->
            vecOf(key);
          }, { ->
            filter(keys, { k -> not(eq(k, key));});
          });
      }, { -> keys; });

    Stage::match(stage, { menuState ->
        let newStage = update(resources, newKeys, menuState);
        State(resources, newKeys, newStage, highScores);
    }, { gameState ->
        let gameResult = update(resources, newKeys, gameState);
        GameResult::match(gameResult, { newGameState ->
            State(resources, newKeys, Stage::Game(newGameState), highScores);
        }, { score -> State(resources, newKeys, Stage::Menu(MenuState(0)), highScores);});

    });
}

fn render(ren: SDLRenderer, state: State) {
    sdlSetRenderDrawColor(ren, BLACK);
    sdlRenderClear(ren);

    let resources = State::resources(state);
    let stage = State::stage(state);

    Stage::run(stage, { menuState -> render(ren, resources, menuState);}, { gameState -> render(ren, resources, gameState);});

    sdlRenderPresent(ren);
}

fn loadHighScores() -> Vec<HighScore> {
    let result = if(fileExists("scores.txt"), { ->
        let scores = readFile("scores.txt");
        let lines = lines(scores);
        listToVec(fmap(lines, { line ->
            let splitted = splitToList(line, ",");
            let result = map3(splitted, { score, sec, nano -> HighScore(atoi(score), TimeVal(atoi(sec), atoi(nano)));});
            toList(result);
        }));
    }, { -> Vec();});

    forEach(result, { highScore ->
        let score = HighScore::score(highScore);
        let time = HighScore::time(highScore);
        print(score);
        print(", ");
        println(time);
    });

    result;
}

fn writeHighScores(highScores: Vec<HighScore>) {
    let file = createFile("scores.txt");

    forEach(highScores, { it ->
        let score = HighScore::score(it);
        let time = HighScore::time(it);
        let sec = TimeVal::sec(time);
        let nano = TimeVal::nano(time);

        print(file, score);
        print(file, ",");
        print(file, sec);
        print(file, ",");
        println(file, nano);

    });

    sysClose(file);
}

fn print(highScore: HighScore) {
    let score = HighScore::score(highScore);
    let time = HighScore::time(highScore);
    print(score);
    print(", ");
    println(time);
}

fn splitToList(s: str, separator: str) -> List<str> {
    let chars = listEnumerate(chars(s));

    let separatorIndex = findChar(chars, separator);

    Option::match(separatorIndex, { index ->
        let item = substr(s, 0, index);
        let remainder = substr(s, add(index, 1), sub(sub(slen(s), index), 1));
        Option::match(item, { f ->
            Option::match(remainder, { r -> listAppend(listOf(f), splitToList(r, separator));}, { -> listOf(f);});
        }, { -> List::Empty();});
    }, { -> listOf(s);});
}

fn findChar(chars: List<EnumerateEntry<str>>, c: str) -> Option<i32> {
    let o = first(filter(chars, { it ->
        let currentChar = EnumerateEntry::value(it);
        seq(currentChar, c);
    }));

    Option::match(o, { entry -> Option::Some(EnumerateEntry::index(entry));}, { -> Option::None();});
}