struct GameState {
    stage: GameStage,
    world: World,
}

struct World {
    bricks: Vec<Brick>,
    ball: Ball,
    bar: Bar,
    score: i32,
    lives: i32
}

enum GameStage {
    RunBall,
    Run
}

struct Brick {
    x: i32,
    y: i32,
    color: SDLColor
}

enum XDirection {
    Left,
    Right
}

enum YDirection {
    Up,
    Down
}

struct Ball {
    x: f32,
    y: f32,
    xDir: XDirection,
    yDir: YDirection,
    lastUpdate: TimeVal
}

struct Bar {
    x: f32,
    velocity: i32,
    lastUpdate: TimeVal
}

fn initialGameState() -> GameState {
    GameState(GameStage::Run(), initialWorld());
}

fn initialWorld() -> World {
    let bricks = cartesianProduct(vecRange(0, 30), vecRange(0, 10), {x, y -> Brick(mul(x, BRICKWIDTH), add(HEADERHEIGHT, mul(y, BRICKHEIGHT)) , RED); });

    let now = now();

    World(bricks, initialBall(now), Bar(500.0, 0, now), 0, 3);
}

fn initialBall(now: TimeVal) -> Ball {
    Ball(500.0, 200.0, XDirection::Right(), YDirection::Down(), now);
}

fn update(resources: Resources, keys: Vec<i32>, gameState: GameState) -> GameResult {
    let stage = GameState::stage(gameState);
    let world = GameState::world(gameState);

    let newGameState = GameStage::match(stage, { -> gameState;}, { ->
        let newWorld = update(resources, keys, world);
        GameState(stage, newWorld);
    });

    let newWorld = GameState::world(newGameState);
    let lives = World::lives(newWorld);
    let score = World::score(newWorld);

    if(eq(lives, 0) { -> GameResult::End(score);} { -> GameResult::Play(newGameState);});
}

fn update(resources: Resources, keys: Vec<i32>, world: World) -> World {
    // println(time());
    // sleep(0, 1500);
    let actualTime = now();
    let score = World::score(world);
    let lives = World::lives(world);

    let newBar = updateBar(world, actualTime, keys);

    let bricks = World::bricks(world);
    let ball = World::ball(world);
    let lastUpdate = Ball::lastUpdate(ball);
    let elapsed = elapsedTime(actualTime, lastUpdate);

    // TODO I don't like it, it's not smooth, we need floating points!
    if(greater(elapsed, 2000), { ->
        let newBall = updateBall(ball, actualTime);

        let collision = collision(bricks, newBall);

        let newScore = Option::match(collision, { b -> add(score, 10);}, { -> score;});

        let newBricks = Option::match(collision, { b1 -> filter(bricks, { b2 -> not(eq(b1, b2)); }); }, { -> bricks; });
        let barPos = Bar::x(newBar);

        if(collides(newBall, barPos), { ->
            let x = Ball::x(ball);
            let y = Ball::y(ball);
            let xDir = Ball::xDir(ball);
            let yDir = Ball::yDir(ball);

            let newBall2 = updateBall(Ball(x, y, xDir, flip(yDir), actualTime), actualTime);
            World(newBricks, newBall2, newBar, newScore, lives);
        }, { ->
            let y = Ball::y(ball);

            Option::match(collision, { brick ->
                let newBall2 = ballAfterCollision(ball, brick);
                 World(newBricks, newBall2, newBar, newScore, lives);
            },
            { ->
                if(greater(y, sub(HEIGHT, BALLSIZE)), { ->
                    World(newBricks, initialBall(actualTime), newBar, newScore, sub(lives, 1));
                }, { ->
                    World(newBricks, newBall, newBar, newScore, lives);
                });
            });
        });


    }, { -> World(bricks, ball, newBar, score, lives);});

}

fn updateBar(world: World, actualTime: TimeVal, keys: Vec<i32>) -> Bar {
    let bar = World::bar(world);
    let barLastUpdate = Bar::lastUpdate(bar);
    let elapsed = elapsedTime(actualTime, barLastUpdate);

    if(greater(elapsed, 1000), { ->
        let barPos = Bar::x(bar);
        let velocity = Bar::velocity(bar);

        let left = negate(count(keys, { k -> eq(k, 80);}));
        let right = count(keys, { k -> eq(k, 79);});

        let newVelocity = add(left, right);

        let newBarPos = add(barPos, newVelocity);

        Bar(newBarPos, newVelocity, actualTime);
    }, { -> bar;});
}

fn updateBall(ball: Ball, actualTime: TimeVal) -> Ball {
    let x = Ball::x(ball);
    let y = Ball::y(ball);
    let xDir = Ball::xDir(ball);
    let yDir = Ball::yDir(ball);

    let newX = XDirection::match(xDir, { -> sub(x, 1);} , { -> add(x,1);});
    let newY = YDirection::match(yDir, { -> sub(y, 1);} , { -> add(y,1);});

    let newXDir = if(or(greater(newX, sub(WIDTH, BALLSIZE)), less(newX, 1)), { -> flip(xDir); }, { -> xDir;});
    let newYDir = if(or(greater(newY, sub(HEIGHT, BALLSIZE)), less(newY, HEADERHEIGHT)), { -> flip(yDir); }, { -> yDir;});

    Ball(newX, newY, newXDir, newYDir, actualTime);
}

fn eq(b1: Brick, b2: Brick) -> bool {
    let b1x = Brick::x(b1);
    let b1y = Brick::y(b1);

    let b2x = Brick::x(b2);
    let b2y = Brick::y(b2);

    and(eq(b1x, b2x), eq(b1y, b2y));
}

fn collision(bricks: Vec<Brick>, ball: Ball) -> Option<Brick> {
    let x = Ball::x(ball);
    let y = Ball::y(ball);

    first(filter(bricks, { brick -> collides(x, y, brick); }));
}

fn collides(x: f32, y: f32, brick: Brick) -> bool {
    let bx = Brick::x(brick);
    let by = Brick::y(brick);

    let xColl = and(greater(add(x, BALLSIZE), bx), less(x, add(bx, BRICKWIDTH)));
    let yColl = and(greater(add(y, BALLSIZE), by), less(y, add(by, BRICKHEIGHT)));

    and(xColl, yColl);
}

fn collides(ball: Ball, barPos: f32) -> bool {
    let x = Ball::x(ball);
    let y = Ball::y(ball);
    let bx = barPos;
    let by = sub(HEIGHT, BARHEIGHT);

    let xColl = and(greater(add(x, BALLSIZE), bx), less(x, add(bx, BARWIDTH)));
    let yColl = greater(add(y, BALLSIZE), by);

    and(xColl, yColl);
}

fn ballAfterCollision(ball: Ball, brick: Brick) -> Ball {
    let ballX = Ball::x(ball);
    let ballY = Ball::y(ball);
    let xDir = Ball::xDir(ball);
    let yDir = Ball::yDir(ball);
    let lastUpdate = Ball::lastUpdate(ball);

    let brickX = Brick::x(brick);
    let brickY = Brick::y(brick);

    let xDiff1 = sub(ballX, brickX);
    let xDiff2 = sub(add(brickX, BRICKWIDTH), ballX);
    let yDiff1 = sub(ballY, brickY);
    let yDiff2 = sub(add(brickY, BRICKHEIGHT), ballY);

    let xDiff = min(xDiff1, xDiff2);
    let yDiff = min(yDiff1, yDiff2);

    if(less(xDiff, yDiff), { -> Ball(ballX, ballY, flip(xDir), yDir, lastUpdate);}, { -> Ball(ballX, ballY, xDir, flip(yDir), lastUpdate);});
}

fn flip(xDir: XDirection) -> XDirection {
    XDirection::match(xDir, { -> XDirection::Right();}, { -> XDirection::Left(); } );
}

fn flip(yDir: YDirection) -> YDirection {
    YDirection::match(yDir, { -> YDirection::Down();}, { -> YDirection::Up(); } );
}

fn render(ren: SDLRenderer, resources: Resources, gameState : GameState) {
    let stage = GameState::stage(gameState);
    let world = GameState::world(gameState);

    GameStage::run(stage, { -> }, { ->
        render(ren, resources, world);
    });
}

fn render(ren: SDLRenderer, resources: Resources, world: World) {
    let font = Resources::font(resources);
    let bricks = World::bricks(world);
    let score = World::score(world);
    let lives = World::lives(world);

    forEach(bricks, { brick ->
        let x = Brick::x(brick);
        let y = Brick::y(brick);
        let color = Brick::color(brick);

        sdlSetRenderDrawColor(ren, color);

        sdlRenderFillRect(ren, SDLRect(add(x, 1), add(y, 1), sub(BRICKWIDTH, 2), sub(BRICKHEIGHT, 2)));
    });

    sdlSetRenderDrawColor(ren, WHITE);
    let bar = World::bar(world);
    let barPos = Bar::x(bar);

    sdlRenderFillRect(ren, SDLRect(toi32(barPos, 0), sub(HEIGHT, BARHEIGHT), BARWIDTH, BARHEIGHT));

    let ball = World::ball(world);
    let x = Ball::x(ball);
    let y = Ball::y(ball);

    sdlRenderFillRect(ren, SDLRect(toi32(x, 0), toi32(y, 0), BALLSIZE, BALLSIZE));

    sdlSetRenderDrawColor(ren, BLUE);
    sdlRenderFillRect(ren, SDLRect(0, 0, WIDTH, HEADERHEIGHT));

    let scoreText = createSDLText(ren, font, add("Score: ", toString(score)), GREEN);
    render(ren, scoreText, SDLRect(2, 2, 100, 24));
    release(scoreText);

    let livesText = createSDLText(ren, font, add("Lives: ", toString(lives)), GREEN);
    render(ren, livesText, SDLRect(200, 2, 100, 24));
    release(livesText);
}

fn toi32(f: f32, default: i32) -> i32 {
    getOrElse(toi32(f), default);
}