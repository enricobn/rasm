/*  LIST */

enum List<T> {
  Full(head: T, tail: List<T>),
  Empty
}

fn nListPrintln(l: List<i32>) {
    nListPrint(l);
    sprintln("");
}

fn nListPrint(l: List<i32>) {
    List::run(l,
        { head,tail ->
            nprint(head);
            List::run(tail, { head1,tail1 -> sprint(",");}, { -> });
            nListPrint(tail);
        }, { -> });
}

fn range(start: i32, end: i32) -> List<i32> {
    if (less(start, end), { ->
        List::Full(start, range(nadd(start, 1), end));
    }, { ->
        List::Empty();
    });
}

fn listMap<T,T1>(l: List<T>, map: fn(T) -> T1) -> List<T1> {
    List::match(l, { head,tail -> List::Full(map(head), listMap(tail, map)); }, { -> List::Empty();});
}

fn listForeach<T>(l: List<T>, map: fn(T) -> ()) {
    List::run(l, { head,tail -> map(head); listForeach(tail, map); }, { -> });
}

/** false = 0 true = 1 **/
fn listAnyMatch<T>(l: &List<T>, predicate: fn(T) -> i32) -> i32 {
    List::match(l, { head,tail -> if(predicate(head), { -> itn(1); }, { -> listAnyMatch(tail, predicate); }); }, { -> itn(0); });
}

fn listCount<T>(l: List<T>, predicate: fn(T) -> i32) -> i32 {
    List::match(l, { head,tail -> nadd(listCount(tail, predicate), ifImmediate(predicate(head), 1, 0)); }, { -> itn(0); });
}

fn listAddLeft<T>(l: &List<T>, value: T) -> List<T> {
    List::Full(value, l);
}

fn listAddRight<T>(l: &List<T>, value: T) -> List<T> {
    List::match(l, { head, tail -> List::Full(head, listAddRight(tail, value));}, { -> List::Full(value, List::Empty());});
}

fn listOf<T>(v: T) -> List<T> {
    List::Full(v, List::Empty());
}

fn listOf2<T>(v1: T, v2: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Empty()));
}

fn listOf3<T>(v1: T, v2: T, v3: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Full(v3, List::Empty())));
}

fn listOf4<T>(v1: T, v2: T, v3: T, v4: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Full(v3, List::Full(v4, List::Empty()))));
}

fn listOf5<T>(v1: T, v2: T, v3: T, v4: T, v5: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Full(v3, List::Full(v4, List::Full(v5, List::Empty())))));
}

fn listOf6<T>(v1: T, v2: T, v3: T, v4: T, v5: T, v6: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Full(v3, List::Full(v4, List::Full(v5, List::Full(v6, List::Empty()))))));
}

fn listOf7<T>(v1: T, v2: T, v3: T, v4: T, v5: T, v6: T, v7: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Full(v3, List::Full(v4, List::Full(v5, List::Full(v6, List::Full(v7, List::Empty())))))));
}

fn listOf8<T>(v1: T, v2: T, v3: T, v4: T, v5: T, v6: T, v7: T, v8: T) -> List<T> {
    List::Full(v1, List::Full(v2, List::Full(v3, List::Full(v4, List::Full(v5, List::Full(v6, List::Full(v7, List::Full(v8, List::Empty()))))))));
}

fn listPrintln<T>(l: List<T>, print: fn(T) -> ()) {
    listPrint(l, print);
    sprintln("");
}

fn listPrint<T>(l: List<T>, printFunction: fn(T) -> ()) {
    List::run(l, { head,tail ->
        printFunction(head);
        List::run(tail, { head1,tail1 -> sprint(","); }, { -> });
        listPrint(tail, printFunction);
    }, { -> });
}

fn listFMap<T,T1>(l: List<T>, map: fn(T) -> List<T1>) -> List<T1> {
    listFlatten(listMap(l, map));
}

fn listFlatten<T>(l: List<List<T>>) -> List<T> {
    List::match(l, { head, tail ->
        listAppend(head, listFlatten(tail));
    },
    { -> List::Empty(); });
}

fn listAppend<T>(dest: List<T>, source: List<T>) -> List<T> {
    List::match(dest, { head,tail -> List::Full(head, listAppend(tail, source)); }, { -> source;});
}

fn listFoldL<T,T1>(l: List<T>, zero: T1, accum: fn(T1,T) -> T1) -> T1 {
    List::match(l, { head, tail ->
         listFoldL(tail, accum(zero, head), accum);
    }, { -> zero; });
}

fn listFoldR<T,T1>(l: List<T>, zero: T1, accum: fn(T1,T) -> T1) -> T1 {
    listFoldL(listReverse(l), zero, accum);
}

fn listReverse<T>(l: List<T>) -> List<T> {
    List::match(l, { head, tail ->
        listAppend(listReverse(tail), listOf(head));
    }, { -> List::Empty(); });
}

fn listFilter<T>(l: List<T>, filter: fn(T) -> i32) -> List<T> {
    List::match(l, { head, tail ->
        if(filter(head), { -> List::Full(head, listFilter(tail, filter)); }, { -> listFilter(tail, filter);});
    }, { -> List::Empty(); });
}

asm lines(s: str) -> List<str> /{
    push ebx
    push ecx
    push edx

    mov ebx, 0 ; pos of start of line
    mov edx, 0 ; actual pos
    $call(newStrList)

.loop:
    mov dword ecx, $s
    mov dword ecx, [ecx]
    add ecx, edx
    cmp     byte [ecx], 0
    jz  .endOfString
    cmp     byte [ecx], 10
    je  .endOfLine
    inc edx
    jmp .loop

.endOfLine:
    mov     ecx, edx
    sub     ecx, ebx
    push    eax
    $call(substr, $s, ebx, ecx)
    ; it's an option of string
    ; so we get the real address to the option
    mov     dword eax,[eax]
    ; then we skip the first word that is the value for the "Some" variant (TODO check)
    add     eax, 4
    ; then we get the pointer to the allocation table of the string, that is what we need
    mov     dword eax,[eax]
    mov     ebx, eax
    pop     eax
    $call(addStrToList, eax, ebx)
    inc edx
    mov ebx, edx
    jmp .loop

.endOfString:
    cmp     ebx, edx
    je      .end
    push    eax
    mov     ecx, edx
    sub     ecx, ebx
    $call(substr, $s, ebx, ecx)
    mov     ebx, eax
    pop     eax
    $call(addStrToList, eax, ebx)

.end:
    pop edx
    pop ecx
    pop ebx
}/

fn addStrToList(l: List<str>, s: str) -> List<str> {
    listAddRight(l, s);
}

fn newStrList() -> List<str> {
    List::Empty();
}