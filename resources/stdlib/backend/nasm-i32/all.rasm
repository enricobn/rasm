include "compiler.rasm"
include "conditionals.rasm"
include "debug.rasm"
include "io.rasm"
include "list.rasm"
include "math.rasm"
include "new_allocator.rasm"
include "logic.rasm"
include "str.rasm"
include "vec.rasm"

extern "exit"

asm exitMain(status: i32) /{
    %ifdef LIBC
    push    dword $status
    call    exit
    %else
    mov     ebx, $status    ; Arg one: the status
    mov     eax, 1          ; Syscall number: 1
    int     0x80
    %endif
}/

asm argc() -> i32 /{
    mov     eax,[_rasm_args]
}/

// TODO unsafe use Option
asm argv(i: i32) -> str /{
    push edx ; since the mul function stores the result even in edx
    push ebx
    push ecx
    mov ebx, _rasm_args
    mov ecx,4           ; i add 4*i to the base address (_rasm_args)
    mov eax,$i
    inc eax             ; we skip the length (argc)
    mul ecx
    add ebx,eax
    mov eax,[ebx]
    pop ecx
    pop ebx
    pop edx
}/

// from https://stackoverflow.com/questions/19580282/nasm-assembly-linux-timer-or-sleep
// TODO use TimeVal
asm sleep(sec: i32, nsec: i32) -> i32 /{
    push ebx
    push ecx
    mov dword eax,$sec
    mov dword [tv_sec], eax
    mov dword eax,$nsec
    mov dword [tv_usec], eax
    mov eax, 162
    mov ebx, timeval
    mov ecx, 0
    int 0x80
    pop ecx
    pop ebx
}/

struct TimeVal {
    sec: i32,
    nano: i32
}

asm now() -> TimeVal /{
    push    ecx
    push    ebx
    $call(TimeVal, 0, 0)
    push    dword eax
    mov     ebx, [eax]
    $call(malloc, 8, " for TimeVal")
    $call(freeMem, eax)
    mov     dword ecx, [eax]  ; timezone
    mov     eax, 78           ; call number = gettimeofday
    int     0x80
    pop     eax
    pop     ebx
    pop     ecx
}/

fn elapsedTime(actual: TimeVal, previous: TimeVal) -> i32 {
    let secA = TimeVal::sec(actual);
    let nanoA = TimeVal::nano(actual);
    let secP = TimeVal::sec(previous);
    let nanoP = TimeVal::nano(previous);

    add(mul(1000000, sub(secA, secP)), sub(nanoA, nanoP));
}

fn print(timeVal: TimeVal) {
    let sec = TimeVal::sec(timeVal);
    let nano = TimeVal::nano(timeVal);
    print("sec=");
    print(sec);
    print(" nano=");
    print(nano);
}

asm memcopy(source: i32, dest: i32, len: i32) /{
    push    ecx
    push    esi
    push    edi
    mov     esi, $source
    mov     edi, $dest
    mov     ecx, $len

; first we copy word by word
.loop4:
    cmp     ecx, 4
    jb      .loop1
    movsd
    sub     ecx,4
    jmp     .loop4

.loop1:
    add     ecx,1
; then byte by byte
.loop:
    sub     ecx,1
    jz      .end
    movsb
    jmp     .loop
.end:
    pop     edi
    pop     esi
    pop     ecx
}/

asm toString(n: i32) -> str /{
    push    esi
    push    ebx
    push    ecx
    push    edx

    $call(malloc, 20, " temp for toString(i32)")
    push eax

    $call(addRef, eax, "")

    mov     dword esi,[eax]

    add     esi,19

    mov     eax,$n ; integer value to convert
    mov     byte [esi],0    ; String terminator

    mov ebx,10
    xor ecx,ecx         ; initialize length
.next_digit:
    xor edx,edx         ; Clear edx prior to dividing edx:eax by ebx
    div ebx             ; eax /= 10
    add dl,'0'          ; Convert the remainder to ASCII
    dec esi             ; store characters in reverse order
    inc ecx             ; length

    mov [esi],dl
    test eax,eax
    jnz .next_digit     ; Repeat until eax==0

    inc    ecx          ; The length + 1, I think the 0 at the end...
    $call(malloc, ecx, " for toString(i32)")

    $call(memcopy, esi, [eax], ecx)

    pop     edx
    $call(freeMem, edx)

    pop    edx
    pop    ecx
    pop    ebx
    pop    esi
}/