fn nVecPrintln(v: Vec<i32>) {
    vecForeach(v, { n -> nprint(n); sprint(",");});
    println();
}

asm vecOf<T>(value: T) -> Vec<T> /{
    $call(malloc, 8)
    push    eax
    mov     dword eax, [eax]
    mov     dword [eax], 1
    add     eax, 4
    push    ebx
    mov     dword ebx, $value
    mov     dword [eax], ebx
    pop     ebx
    pop     eax
}/

asm vecForeach<T>(vec: Vec<T>, f: fn(T) -> ()) /{
    push    ebx
    push    ecx
    push    edx
    mov     dword ebx, $vec
    mov     dword ebx, [ebx]
    mov     dword ecx, [ebx]    ; count
    add     ebx, 4  ; address of first value
    mov     edx, $f         ; points to the lambda space
.loop:
    cmp     dword ecx, 0
    jz      .end
    push    dword [ebx]
    push    edx             ; the address to the lambda space is the last argument of every lambda
    call    [edx]           ; in the first 4 bytes of the lambda space there is the address of the lambda function to call
    add     esp, 8
    add     ebx, 4
    dec     ecx
    jmp     .loop

.end:
    pop     edx
    pop     ecx
    pop     ebx
}/

// end exclusive
asm vecRange(start: i32, end: i32) -> Vec<i32> /{
    push    ebx
    push    ecx
    push    edx

    mov     dword ebx, $end
    sub     dword ebx, $start
    push    ebx                 ; the size
    inc     ebx                 ; + 1 for the size
    add     ebx, ebx
    add     ebx, ebx
    $call(malloc, ebx)
    pop     ebx
    push    eax
    mov     dword ecx, [eax]
    mov     dword [ecx], ebx    ; the size
    add     ecx, 4              ; the pointer to the next value
    mov     dword edx, 0        ; the actual value
.loop:
    cmp     dword ebx, 0
    jz      .end
    mov     dword [ecx], edx

    add     ecx, 4
    dec     ebx
    inc     edx
    jmp     .loop
.end:
    pop     eax
    ; $call(sprint, "vecRange ")
    ; $call(nprintln, eax)
    pop     edx
    pop     ecx
    pop     ebx
}/

asm vecMap<T,T1>(vec: Vec<T>, f: fn(T) -> T1) -> Vec<T1>/{
    push    ebx
    push    ecx
    push    edx

    mov     dword ebx, $vec
    mov     dword ebx, [ebx]    ; the address of the allocated memory
    mov     dword ecx, [ebx]    ; size
    push    ecx
    inc     ecx                 ; + 1 for the size
    add     ecx, ecx
    add     ecx, ecx
    $call(malloc, ecx)
    pop     ecx
    push    eax
    mov     dword eax, [eax]
    mov     dword [eax], ecx
    mov     edx, eax
    add     edx, 4          ; address of first value to write
    add     ebx, 4          ; address of first value to read
.loop:
    cmp     dword ecx, 0
    jz      .end
    push    dword [ebx]
    push    dword $f
    mov     dword eax, $f
    call    [eax]
    add     esp, 8
    mov     dword [edx], eax
    add     ebx, 4
    add     edx, 4
    dec     ecx
    jmp .loop
.end:
    pop     eax
    pop     edx
    pop     ecx
    pop     ebx
}/

/** false = 0 true = any other value **/
asm vecAnyMatch<T>(vec: Vec<T>, f: fn(T) -> i32) -> i32 /{
    ; $call(sprint, "vecAnyMatch ")
    ; $call(nprintln, $vec)

    push    ebx
    push    ecx

    mov     dword ebx, $vec
    mov     dword ebx, [ebx]    ; the address of the allocated memory
    mov     dword ecx, [ebx]    ; size
    add     ebx, 4              ; the address of the first value
.loop:
    cmp     dword ecx, 0
    jz      .false
    ; $call(sprint, "  n ")
    ; $call(nprint, [ebx])
    push    dword [ebx]
    push    dword $f
    mov     dword eax, $f
    call    [eax]
    ; $call(sprint, " = ")
    ; $call(nprintln, eax)
    add     esp, 8
    cmp     dword eax, 0
    jnz      .true
    add     ebx, 4
    dec     ecx
    jmp     .loop
.false:
    mov     dword eax, 0
    jmp     .end
.true:
    mov     dword eax, 1
.end:
    ; $call(sprint, "  result = ")
    ; $call(nprintln, eax)
    pop     ecx
    pop     ebx
}/

asm vecCount<T>(vec: Vec<T>, f: fn(T) -> i32) -> i32 /{
    ; $call(sprintln, "vecCount")
    push    ebx
    push    ecx
    push    edx

    mov     dword ebx, $vec
    mov     dword ebx, [ebx]    ; the address of the allocated memory
    mov     dword ecx, [ebx]    ; size
    add     ebx, 4              ; the address of the first value
    mov     dword edx, 0        ; result
.loop:
    cmp     dword ecx, 0
    jz      .end
    push    dword [ebx]
    push    dword $f
    mov     dword eax, $f
    call    [eax]
    add     esp, 8
    cmp     dword eax, 0
    jz      .false
    inc     edx
.false:
    add     ebx, 4
    dec     ecx
    jmp     .loop
.end:
    mov     dword eax, edx
    pop     edx
    pop     ecx
    pop     ebx
}/

asm vecFilter<T>(vec: Vec<T>, filter: fn(T) -> i32) -> Vec<T> /{
    push    ebx
    push    ecx
    push    edx

    mov     dword eax, $vec
    mov     dword ecx, [eax]
    mov     dword ebx, [ecx]    ; the size of the original array
    add     ecx, 4              ; the address of the value in the old array

    push    ebx
    ; multiply ebx by 4
    shl     ebx, 2
    ; add the space for the size
    add     ebx, 4
    $call(malloc, ebx)
    pop     ebx

    push    eax

    mov     dword edx, [eax]
    add     edx, 4  ; the address of the value in the new array


.loop:
    cmp     ebx, 0
    jz      .end
    push    dword [ecx]
    push    dword $filter
    mov     dword eax, $filter
    call    [eax]
    add     esp, 8
    cmp     dword eax, 0
    jz      .false
    mov     dword eax, [ecx]
    mov     dword [edx], eax
    add     edx, 4
.false
    dec     ebx
    add     ecx, 4
    jmp     .loop
.end:
    pop     eax
    sub     edx, [eax]
    ; divide ebx by 4, we get the len
    shr     edx, 2
    dec     edx         ; we remove 1 for the size
    mov     dword ecx, [eax]
    mov     dword [ecx], edx
    pop     edx
    pop     ecx
    pop     ebx
}/

asm vecOf8<T>(v1: T, v2: T, v3: T, v4: T, v5: T, v6: T, v7: T, v8: T) -> Vec<T> /{
    $call(malloc, 36)
    push    eax
    mov     dword eax, [eax]
    mov     dword [eax], 8
    add     eax, 4

    push    ebx

    mov     dword ebx, $v1
    mov     dword [eax], ebx

    add     eax, 4
    mov     dword ebx, $v2
    mov     dword [eax], ebx

    add     eax, 4
    mov     dword ebx, $v3
    mov     dword [eax], ebx

    add     eax, 4
    mov     dword ebx, $v4
    mov     dword [eax], ebx

    add     eax, 4
    mov     dword ebx, $v5
    mov     dword [eax], ebx

    add     eax, 4
    mov     dword ebx, $v6
    mov     dword [eax], ebx

    add     eax, 4
    mov     dword ebx, $v7
    mov     dword [eax], ebx

    add     eax, 4
    mov     dword ebx, $v8
    mov     dword [eax], ebx

    pop     ebx
    pop     eax
}/

// TODO I think it cannot be used, since we cannot determine the type of T
asm Vec<T>() -> Vec<T> /{
    $call(malloc, 4)
    push    eax
    mov     dword eax, [eax]
    mov     dword [eax], 0
    pop     eax
}/