type Vec<T>(true);

fn cartesianProduct<T1,T2,T>(vec1: Vec<T1>, vec2: Vec<T2>, zipFunction: fn(T1, T2) -> T) -> Vec<T> {
    fmap(vec1, { v1 ->
        map(vec2, { v2 -> zipFunction(v1, v2); });
    });
}

fn fmap<T,T1>(l: Vec<T>, f: fn(T) -> Vec<T1>) -> Vec<T1> {
    flatten(map(l, f));
}

fn listToVec<T>(l: List<T>) -> Vec<T> {
    List::match(l, { head, tail -> flatten(vecOf(vecOf(head), listToVec(tail)));},
        { -> Vec(); });
}

fn print<T>(v: Vec<T>, printFunction: fn(T) -> ()) {
    forEach(v, { n -> printFunction(n); print(",");});
}

fn print<T>(v: Vec<T>) {
    forEach(v, { n -> print(n); print(",");});
}

fn enumerate<T>(vec: Vec<T>) -> Vec<EnumerateEntry<T>> {
    zip(vecRange(0, length(vec)), vec, { index, value -> EnumerateEntry(index, value);});
}

// TODO it's really slow!!!
fn sort<T>(vec: Vec<T>) -> Vec<T> {
    ifImmediateThen(less(length(vec), 2), vec, { ->
        let firstOfVec = first(vec);
        Option::match(firstOfVec, { f ->
            let l = filter(vec, { v -> Compare::match(cmp(v, f), { -> true;}, { -> false;}, { -> false;});});
            let e = filter(vec, { v -> Compare::match(cmp(v, f), { -> false;}, { -> true;}, { -> false;});});
            let g = filter(vec, { v -> Compare::match(cmp(v, f), { -> false;}, { -> false;}, { -> true;});});
            let result = add(sort(l), add(sort(e), sort(g)));
            ifImmediateThen(eq(result, vec), vec, { -> sort(result);});
        }, { -> Vec();});
    });
}

// TODO it's really slow!!!
fn sort<T>(vec: Vec<T>, cmpFunction: fn(T, T) -> Compare) -> Vec<T> {
    ifImmediateThen(less(length(vec), 2), vec, { ->
        let firstOfVec = first(vec);
        Option::match(firstOfVec, { f ->
            let l = filter(vec, { v -> Compare::match(cmpFunction(v, f), { -> true;}, { -> false;}, { -> false;});});
            let e = filter(vec, { v -> Compare::match(cmpFunction(v, f), { -> false;}, { -> true;}, { -> false;});});
            let g = filter(vec, { v -> Compare::match(cmpFunction(v, f), { -> false;}, { -> false;}, { -> true;});});
            let result = add(sort(l, cmpFunction), add(sort(e, cmpFunction), sort(g, cmpFunction)));
            ifImmediateThen(eq(result, vec, cmpFunction), vec, { -> sort(result, cmpFunction);});
        }, { -> Vec();});
    });
}

fn eq<T>(vec1: Vec<T>, vec2: Vec<T>) -> bool {
    ifImmediateThen(not(eq(length(vec1), length(vec2))), false, { ->
        let booleans = zip(vec1, vec2, { v1, v2 -> eq(v1, v2);});
        eq(count(booleans, { v -> not(v);}), 0);
    });
}

fn eq<T>(vec1: Vec<T>, vec2: Vec<T>, cmpFunction: fn(T, T) -> Compare) -> bool {
    ifImmediateThen(not(eq(length(vec1), length(vec2))), false, { ->
        let booleans = zip(vec1, vec2, { v1, v2 ->
            Compare::match(cmpFunction(v1, v2), { -> false;}, { -> true;}, { -> false;});
        });
        eq(count(booleans, { v -> not(v);}), 0);
    });
}

