type Vec<T>(true);

fn cartesianProduct<T1,T2,T>(vec1: Vec<T1>, vec2: Vec<T2>, zipFunction: fn(T1, T2) -> T) -> Vec<T> {
    fmap(vec1, { v1 ->
        map(vec2, { v2 -> zipFunction(v1, v2); });
    });
}

fn fmap<T,T1>(l: Vec<T>, f: fn(T) -> Vec<T1>) -> Vec<T1> {
    flatten(map(l, f));
}

fn listToVec<T>(l: List<T>) -> Vec<T> {
    List::match(l, { head, tail -> flatten(vecOf(vecOf(head), listToVec(tail)));},
        { -> Vec(); });
}

fn print<T>(v: Vec<T>, printFunction: fn(T) -> ()) {
    forEach(v, { n -> printFunction(n); print(",");});
}

fn print<T>(v: Vec<T>) {
    forEach(v, { n -> print(n); print(",");});
}

fn enumerate<T>(vec: Vec<T>) -> Vec<EnumerateEntry<T>> {
    zip(vecRange(0, length(vec)), vec, { index, value -> EnumerateEntry(index, value);});
}

