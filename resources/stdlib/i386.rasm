/**
 * Prints the number to standard output.
 * TODO it supports only 10 digits
 * https://stackoverflow.com/questions/25064565/printing-an-integer-with-x86-32-bit-linux-sys-write-nasm
 **/
asm nprint(n: i32) /{
    push    esi
    push    eax
    push    ebx
    push    ecx
    push    edx
    mov     eax,$n ; integer value to convert
    mov     esi,_rasm_buffer_10b
    add     esi,9
    mov     byte [esi],0    ; String terminator

    mov ebx,10
    xor ecx,ecx         ; initialize length
.next_digit:
    xor edx,edx         ; Clear edx prior to dividing edx:eax by ebx
    div ebx             ; eax /= 10
    add dl,'0'          ; Convert the remainder to ASCII
    dec esi             ; store characters in reverse order
    inc ecx             ; length

    mov [esi],dl
    test eax,eax
    jnz .next_digit     ; Repeat until eax==0

    mov    edx,ecx ; the length
    mov    ecx,esi ; the pointer to the first digit (not necessarily the start of the provided buffer)
    mov    ebx, 1  ; stdout
    mov    eax, 4  ; write
    int    80h

    pop    edx
    pop    ecx
    pop    ebx
    pop    eax
    pop    esi
}/

/**
 * Prints a new line to standard output.
 */
asm println() /{
    push    eax
    mov     eax, 0Ah    ; move 0Ah into eax - 0Ah is the ascii character for a linefeed
    push    eax         ; push the linefeed onto the stack so we can get the address
    push    esp         ; push the address of the current stack pointer where is the \n char for sprint
    call    sprint      ; call our sprint function
    add     esp,8       ; remove parameters from the stack
    pop     eax
}/

/**
 * Prints the string to the standard output.
 **/
asm sprint(s: &str) /{
    push    edx
    push    ecx
    push    ebx
    push    eax
    mov     eax,$s
    push    eax
    call    slen

    mov     edx, eax
    pop     eax

    mov     ecx, eax
    mov     ebx, 1
    mov     eax, 4
    int     80h

    pop     eax
    pop     ebx
    pop     ecx
    pop     edx
}/

fn printESC() /{
    push    eax
    push    ebx
    push    ecx
    push    edx
    mov     edx, 1 ; num of chars
    mov     ecx, _ESC
    mov     ebx, 1
    mov     eax, 4
    int     80h
    pop     edx
    pop     ecx
    pop     ebx
    pop     eax
}/

/** Returns the length of the string **/
asm slen(s: &str) -> i32 /{
    push    ebx             ; Save ebx to the stack since we use it
    mov     eax, $s         ; Get the parameter from the stack (4 the PC + 4 ebp) and put it in eax
    mov     ebx, eax

.nextchar:
    cmp     byte [eax], 0
    jz      .finished
    inc     eax
    jmp     .nextchar

.finished:
    sub     eax, ebx
    pop     ebx
}/

/** Adds two numbers **/
inline asm nadd(n1: i32, n2: i32) -> i32 /{
    mov     eax, $n1
    add     eax, $n2
}/

/** false = 0 true = any other value **/
inline asm if<T>(cond: i32, ftrue: fn() -> T, ffalse: fn() -> T) -> T /{
    mov     eax,$cond
    cmp     eax, 0
    jz      $+13
    mov     eax, $ftrue     ; ftrue points to the lambda space
    push    eax             ; the address to the lambda space is the last argument of every lambda
    call    [eax]           ; in the first 4 bytes of the lambda space there is the address of the lambda function to call
    add     esp, 4
    jmp     $+11
    mov     eax, $ffalse    ; ffalse points to the lambda space, we do the same as above
    push    eax
    call    [eax]           ; false value
    add     esp, 4
}/

/** false = 0 true = any other value **/
inline asm ifRun(cond: i32, ftrue: fn() -> (), ffalse: fn() -> ()) /{
    mov     eax,$cond
    cmp     eax, 0
    jz      $+13
    mov     eax, $ftrue     ; ftrue points to the lambda space
    push    eax             ; the address to the lambda space is the last argument of every lambda
    call    [eax]           ; in the first 4 bytes of the lambda space there is the address of the lambda function to call
    add     esp, 4
    jmp     $+11
    mov     eax, $ffalse    ; ffalse points to the lambda space, we do the same as above
    push    eax
    call    [eax]           ; false value
    add     esp, 4
}/

/**
    false = 0 true = any other value

    ATTENTION: it is not short circuit, it always evaluates both arguments before calling the function,
    if you need a short circuit then use if function
    false = 0 true = any other value
**/
inline asm ifImmediate<T>(cond: i32, vtrue: T, vfalse: T) -> T /{
    mov     eax,$cond
    cmp     eax, 0
    jz      $+10
    mov     eax, $vtrue
    jmp     $+11
    nop     ; nops are used because it's inlined and $vtrue could be an immediate value or an address so we don't know where to jump exactly...
    nop
    nop
    mov     eax, $vfalse
    nop     ; nops are used because it's inlined and $vfalse could be an immediate value or an address so we don't know where to jump exactly...
    nop
    nop
}/

/**
    false = 0 true = any other value

    ATTENTION: the true branch is not short circuit, it is always evaluated before calling the function,
    if you need a full short circuit then use the if function
    false = 0 true = any other value
**/
inline asm ifImmediateThen<T>(cond: i32, vtrue: T, ffalse: fn() -> T) -> T /{
    mov     eax,$cond
    cmp     eax, 0
    jz      $+10
    mov     eax, $vtrue
    jmp     $+14
    nop     ; nops are used because it's inlined and $vtrue could be an immediate value or an address so we don't know where to jump exactly...
    nop
    nop
    mov     eax, $ffalse
    push    eax
    call    [eax]
    add     esp, 4
}/

/** TODO it should be a bool
 *  a  <= b
 *  false = 0 true = any other value
 **/
inline asm lessOrEqual(a: i32, b: i32) -> i32 /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    jbe     $+7  ; Jump if Below or Equal (unsigned comparison)
    mov     eax,0 ; false
}/

/** TODO it should be a bool
 *  a  < b
 *  false = 0 true = any other value
 **/
inline asm less(a: i32, b: i32) -> i32 /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    jb     $+7  ; Jump if Below or Equal (unsigned comparison)
    mov     eax,0 ; false
}/

/** TODO it should be a bool
 *  a  <= b
 *  false = 0 true = any other value
 **/
inline asm greater(a: i32, b: i32) -> i32 /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    jg      $+7  ; Jump if greater (unsigned comparison)
    mov     eax,0 ; false
}/

/** TODO it should be a bool
 *  a  == b
 *  false = 0 true = any other value
 **/
inline asm eq(a: i32, b: i32) -> i32 /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    je      $+7  ; Jump if equals
    mov     eax,0 ; false
}/

asm exit(status: i32) /{
    mov     ebx, $status    ; Arg one: the status
    mov     eax, 1          ; Syscall number:
    int     0x80
}/

asm argc() -> i32 /{
    mov     eax,[_rasm_args]
}/

// TODO unsafe
asm argv(i: i32) -> i32 /{
    push ebx
    push ecx
    mov ebx, _rasm_args
    mov ecx,4           ; i add 4*i to the base address (_rasm_args)
    mov eax,$i
    inc eax             ; we skip the length (argc)
    mul ecx
    add ebx,eax
    mov eax,[ebx]
    pop ecx
    pop ebx
}/

/**
 * parse a string to a number
 from https://stackoverflow.com/questions/19461476/convert-string-to-int-x86-32-bit-assembler-using-nasm
 **/
asm atoi(s: &str) -> i32 /{
    push    ecx
    push    edx
    mov edx, $s ; our string
    xor eax, eax ; zero a "result so far"
    .top:
    movzx ecx, byte [edx] ; get a character
    inc edx ; ready for next one
    cmp ecx, '0' ; valid?
    jb .done
    cmp ecx, '9'
    ja .done
    sub ecx, '0' ; "convert" character to number
    imul eax, 10 ; multiply "result so far" by ten
    add eax, ecx ; add in current digit
    jmp .top ; until done
.done:
    pop    edx
    pop    ecx
}/

asm lambdaSpaceMalloc(size: i32) -> i32 /{
    mov     eax,[_lambda_space_stack]
    add     eax,$size
    mov     dword [_lambda_space_stack],eax
    sub     eax,$size
}/

asm lambdaSpaceMdealloc(size: i32) /{
    push    eax
    mov     eax,[_lambda_space_stack]
    sub     eax,$size
    mov     dword [_lambda_space_stack],eax
    pop     eax
}/

asm mallocOld(size: i32) -> i32 /{
    push    ebx
    mov     eax,_heap           ; we store in eax the pointer
    push    dword [eax]         ; we save in the stack the actual next memory location that we must return (in eax)
    mov     dword ebx,[eax]
    add     ebx,$size
    mov     dword [eax],ebx
    pop     eax                 ; we restore from the stack the saved memory location
    pop     ebx
}/

asm malloc(size: i32) -> i32 /{
    push    ebx
    push    ecx
    push    edx

    %ifdef LOG_DEBUG
    call    startMalloc
    push    dword $size
    call    nprintln
    add     esp, 4
    %endif

    mov     dword ebx,0               ; the counter of the position in the heap table
    mov     dword eax,_heap_table     ; the pointer to the heap table
.loop:
    %ifdef LOG_DEBUG
    ;call    loop
    %endif

    ; if there's space in the heap, we create a new, TODO it's fast, but it don't allocate the heap table...
    ;mov     dword ecx,[_heap]
    ;sub     ecx,_heap_buffer
    ;cmp     ecx,[_heap_size]
    ;jb      .new_address

    mov     dword edx,[_heap_table_size]
    cmp     ebx,edx
    jb     .loop_ok
    call    outOfHeapSpace

.loop_ok:
    %ifdef LOG_DEBUG
    ;call    loopOk
    %endif

    cmp     dword [eax],0
    jz      .new_address

    cmp     dword [eax + 4],0 ; allocated flag
    jz      .not_allocated
.loop_ok_2:
    add     eax,4 * 4
    add     ebx,4 * 4
    jmp     .loop

.new_address:
    %ifdef LOG_DEBUG
    call    newAddress
    %endif

    mov     dword ecx,[_heap]
    sub     ecx,_heap_buffer
    cmp     ecx,[_heap_size]
    jb      .new_address_ok
    call     outOfMemory

.new_address_ok:
    %ifdef LOG_DEBUG
    call    newAddressOk
    %endif

    mov     dword ecx,[_heap]
    mov     dword [eax],ecx
    mov     dword edx, $size
    add     ecx, edx
    mov     dword [_heap],ecx
    mov     dword ecx,$size
    mov     dword [eax + 4 * 4],0 ; to be sure that the next slot is considered free
    jmp     .allocate

.not_allocated:
    %ifdef LOG_DEBUG
    call    notAllocated
    %endif

    mov     dword ecx,[eax + 8] ; size
    cmp     ecx,$size
    jb      .loop_ok_2

    %ifdef LOG_DEBUG
    call    reused
    %endif

    mov     dword [eax + 4], 1      ; allocated flag
    mov     dword [eax + 12], 1     ; count
    jmp     .end

.allocate:
    %ifdef LOG_DEBUG
    call    allocate
    %endif

    mov     dword [eax + 4], 1      ; allocated flag
    mov     dword [eax + 8], ecx    ; size
    ;mov     dword [eax + 12], 1    ; count

.end:
    ;mov     dword eax,[eax]

    %ifdef LOG_DEBUG
    call    printTab
    push    dword eax
    call    nprintln
    pop     eax
    call    endMalloc
    %endif

    pop     edx
    pop     ecx
    pop     ebx
}/

asm deref(address: i32, descr: &str) -> i32 /{
    push    eax
    push    ebx

    %ifdef LOG_DEBUG
    call    startDeref
    %endif

    ; TODO for now this function can be called even for "non allocated" values (exactly for a function parametric type), so we check if the address is valid
    mov     dword eax,_heap_table
    cmp     $address,eax
    jb     .end
    add     eax,_heap_table_size
    cmp     $address,eax
    jg      .end

    mov     dword eax,$address

    %ifdef LOG_DEBUG
    call    printTab
    push    dword eax
    call    nprintln
    add     esp,4

    call    printTab
    push    dword $descr
    call    sprintln
    add     esp,4
    %endif

    cmp     dword [eax],0 ; TODO if address == 0 then it should be an error, but for now we ignore it
    jz      .end

    mov     dword ebx,[eax + 12] ; the count
    cmp     ebx,0
    jz      .negative_count
    ;jz      .end

    sub     ebx,1
    mov     dword [eax + 12],ebx
    cmp     ebx,0
    jnz     .end

    %ifdef LOG_DEBUG
    call    deallocated
    call    printTab
    push    eax
    call    nprintln
    pop     eax
    %endif
    mov     dword [eax + 4],0; allocated false
    jmp     .end
.negative_count:
    call    negativeCount
.end:
    %ifdef LOG_DEBUG
    call    endDeref
    %endif
    pop     ebx
    pop     eax
}/

asm addRef(address: i32) /{
    push    eax
    push    ebx

    %ifdef LOG_DEBUG
    call    startAddRef
    %endif

    ; TODO for now this function can be called even for "non allocated" values (exactly for a function parametric type), so we check if the address is valid
    mov     dword eax,_heap_table
    cmp     $address,eax
    jb     .end
    add     eax,_heap_table_size
    cmp     $address,eax
    jg      .end

    mov     dword eax,$address

    %ifdef LOG_DEBUG
    call    printTab
    push    dword eax
    call    nprintln
    add     esp,4
    %endif

    mov     dword ebx,[eax + 12] ; the count
    add     ebx,1
    mov     dword [eax + 12],ebx
.end:
    %ifdef LOG_DEBUG
    call    endAddRef
    %endif

    pop     ebx
    pop     eax
}/

fn endDeref() {
    sprintln("end deref");
}

fn endAddRef() {
    sprintln("end add_ref");
}

fn startAddRef() {
    sprintln("start add_ref");
}

fn deallocated() {
    sprintln("  deallocated");
}

fn endMalloc() {
    sprintln("end malloc");
}

fn startMalloc() {
    sprint("start malloc ");
}

fn startDeref() {
    sprintln("start deref ");
}

fn printTab() {
    sprint("  ");
}

fn loop() {
    sprintln("  .loop");
}

fn loopOk() {
    sprintln("  .loop_ok");
}

fn newAddress() {
    sprintln("  .new_address");
}

fn newAddressOk() {
    sprintln("  .new_address_ok");
}

fn allocate() {
    sprintln("  .allocate");
}

fn notAllocated() {
    sprintln("  .not_allocated");
}

fn reused() {
    sprintln("  reused");
}

asm printAllocatedOld() /{
    push    eax

    mov     dword eax,[_heap]
    sub     eax,[_original_heap]
    push    eax
    call    nprint
    add     esp, 4
    call    printAllocatedString

    pop     eax
}/

asm printAllocated() /{
    push    eax
    push    ebx
    push    ecx
    push    edx

    mov     dword eax,_heap_table
    mov     dword ebx,0
    mov     dword ecx,0
.loop:
    cmp     dword ebx,[_heap_table_size]
    jge     .end
    mov     dword edx,[eax + 4]; 1 == allocated
    cmp     dword edx,0
    jz      .not_allocated
    add     dword ecx,[eax + 8] ; size
.not_allocated:
    add     eax, 4 * 4
    add     ebx, 4 * 4
    jmp     .loop
.end:
    push    ecx
    call    nprint
    add     esp, 4
    call    printAllocatedString

    pop     edx
    pop     ecx
    pop     ebx
    pop     eax
}/

asm printTableSlotsAllocated() /{
    push    eax
    push    ebx

    mov     dword eax,0
    mov     dword ebx,_heap_table
.loop:
    cmp     dword [ebx],0
    jz      .end
    add     eax,1
    add     ebx,4*4
    jmp     .loop
.end:
    push    eax
    call    nprint
    add     esp, 4
    call    printTableSlotsAllocatedString

    pop     ebx
    pop     eax
}/

fn printTableSlotsAllocatedString() {
    sprintln(" table slots allocated");
}

fn printAllocatedString() {
    sprintln(" bytes allocated");
}

fn outOfHeapSpace() {
    sprintln("Out of heap space");
    exit(1);
}

fn negativeCount() {
    sprintln("Negative allocation count");
    exit(1);
}

fn outOfMemory() {
    sprintln("Out of memory");
    exit(1);
}

fn derefAddressNotFound() {
    sprintln("Deref: address not found");
    exit(1);
}

asm mdealloc(mem: &i32, size: i32) /{
    push    ebx
    push    eax
    mov     eax,$mem
    mov     dword ebx,[eax]
    sub     ebx,$size
    mov     dword [eax],ebx
    pop     eax
    pop     ebx
}/

asm memcopy(source: &i32, dest: &i32, len: i32) /{
    push    eax
    push    ebx
    push    ecx
    push    edx
    mov     eax, $source
    mov     ebx, $dest
    mov     ecx, $len
.loop:
    cmp     ecx, 0
    jz      .end
    mov     dword edx,[eax]
    mov     dword [ebx],edx
    add     ebx,4
    add     eax,4
    sub     ecx,1
    jmp     .loop
.end:
    pop     edx
    pop     ecx
    pop     ebx
    pop     eax
}/

// from https://stackoverflow.com/questions/19580282/nasm-assembly-linux-timer-or-sleep
asm sleep(sec: i32, nsec: i32) -> i32 /{
    push ebx
    push ecx
    mov dword eax,$sec
    mov dword [tv_sec], eax
    mov dword eax,$nsec
    mov dword [tv_usec], eax
    mov eax, 162
    mov ebx, timeval
    mov ecx, 0
    int 0x80
    pop ecx
    pop ebx
}/

// TODO get rid of this, for now is used to return constants
inline asm itn(n: i32) -> i32 /{
    mov     eax,$n
}/