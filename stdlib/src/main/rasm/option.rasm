pub enum Option<T> {
  Some(value : T),
  None
}

pub fn toList<T>(o: Option<T>) -> List<T> {
    match(o, fn(v) {listOf(v);}, fn() {List::Empty();});
}

pub fn print<T>(o: Option<T>) {
    match(o, fn(v) { print("Some("); print(v); print(")");}, fn() {print("None");});
}

pub fn getOrElse<T>(o: Option<T>, default: T) -> T {
    match(o, fn(v) {v;}, fn() {default;});
}

pub fn run<T>(o: Option<T>, f: fn(T) -> ()) {
    match(o, f, fn() {});
}

pub fn map<T,T1>(o: Option<T>, f: fn(T) -> T1) -> Option<T1> {
    match(o, fn(v) {Option::Some(f(v)); }, fn() {Option::None();});
}

pub fn flatten<T>(o: Option<Option<T>>) -> Option<T> {
    match(o, fn(v) {v;}, fn() {Option::None(); });
}

pub fn fmap<T,T1>(o: Option<T>, f: fn(T) -> Option<T1>) -> Option<T1> {
    flatten(map(o, f));
}

pub fn or<T>(o: Option<T>, o1: Option<T>) -> Option<T> {
    match(o, fn(v) { o; }, fn() { o1; });
}

pub fn orElse<T>(o: Option<T>, f: fn() -> Option<T>) -> Option<T> {
    match(o, fn(v) {o; }, f);
}

pub inline native toUnit<T>(o: Option<T>) /{
}/

pub fn isSome<T>(o: Option<T>) -> bool {
    o.match(fn(v) {true; }, fn() {false; });
}

pub fn toString<T>(o: Option<T>) -> str {
    o.match( fn(value) {"Some(".add(value).add(")"); }, fn() {"None"; });
}