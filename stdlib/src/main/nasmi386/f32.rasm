pub native tof32(n: int) -> float /{
    push    ebx
    push    ecx

    ; $call(print, "tof32(", $n)
    ; $call(println, ")")
    mov     dword ebx,$n
    mov     dword eax,$n
    and     dword eax,0x80000000
    jz      .positive
    xor     dword ebx,0xFFFFFFFF
    add     dword ebx,1
.positive:
    $call(countBits, ebx)
    ; $call(println, " countBits ", eax)
    mov     dword ecx,24
    sub     dword ecx,eax
    add     dword eax,126
    shl     eax,23
    shl     dword ebx,cl
    and     dword ebx,0x7FFFFF
    or      dword eax,ebx
    ; $call(println, " = ", eax)
    ; sign
    mov     dword ebx,$n
    and     dword ebx,0x80000000
    or      dword eax,ebx

    pop     ecx
    pop     ebx
}/

native countBits(n: int) -> int /{
    push    ebx
    mov     dword eax,0
    mov     dword ebx,$n
.loop:
    cmp     dword ebx,0
    jz      .end
    shr     ebx,1
    inc     eax
    jmp     .loop
.end:
    pop     ebx
}/

pub native toi32(n: float) -> Option<int> /{
    push    ebx
    push    ecx
    push    edx

    ; mantissa
    mov     dword edx, $n
    and     dword edx, 0x7FFFFF

    mov     dword ebx, $n
    and     dword ebx, 0x7F800000
    shr     dword ebx, 23
    ;$call(println, "exponent ", ebx)
    cmp     dword ebx, 255
    jne     .defined
.undefined:
    mov     dword eax,[_enum_stdlib_option_Option_None]
    jmp     .end
.defined:
    cmp     dword ebx, 0
    je      .denorm
    or      dword edx,0x800000
    cmp     dword ebx, 127
    jb      .below
    sub     ebx,126
    $call(getAligned, edx, ebx)
    jmp      .some
.below:
    mov     dword ecx,126
    sub     dword ecx,ebx
    shr     edx,cl
    $call(getAligned, edx, 0)
    jmp     .some
.denorm:
    $call(getAligned, edx, 1)
.some:
    mov     dword edx, $n
    and     dword edx, 0x80000000
    jz      .positive
    $call(negate, eax)
.positive:
    $call(Some, eax)
.end:
    pop     edx
    pop     ecx
    pop     ebx
}/

pub native negate(n: int) -> int /{
    mov     dword eax,$n
    xor     dword eax,0xFFFFFFFF
    inc     dword eax
}/

native getAligned(alignedMantissa: int, intNumbersCount: int) -> int /{
    push    ecx

    mov     dword ecx, 24
    sub     dword ecx, $intNumbersCount
    mov     dword eax, $alignedMantissa
    shr     dword eax, cl

    pop     ecx
}/

// from https://stackoverflow.com/questions/42181811/how-to-add-two-numbers-integer-and-a-float-in-nasm
pub native mul(f1: float, f2: float) -> float /{
    sub     esp,4

    mov     dword eax,$f1
    mov     dword [ebp - 4],eax
    fld     dword [ebp - 4]
    mov     dword eax,$f2
    mov     dword [ebp - 4],eax

    fmul    dword [ebp - 4]
    fstp    dword [ebp - 4]
    mov     dword eax,[ebp - 4]

    add     esp,4
}/

pub native mul(f1: float, n2: int) -> float /{
    sub     esp,4

    mov     dword eax,$f1
    mov     dword [ebp - 4],eax
    fld     dword [ebp - 4]
    mov     dword eax,$n2
    mov     dword [ebp - 4],eax

    fimul    dword [ebp - 4]
    fstp    dword [ebp - 4]
    mov     dword eax,[ebp - 4]

    add     esp,4
}/


pub native div(f1: float, f2: float) -> float /{
    sub     esp,4

    mov     dword eax,$f1
    mov     dword [ebp - 4],eax
    fld     dword [ebp - 4]
    mov     dword eax,$f2
    mov     dword [ebp - 4],eax

    fdiv    dword [ebp - 4]
    fstp    dword [ebp - 4]
    mov     dword eax,[ebp - 4]

    add     esp,4
}/

pub native div(f1: float, n2: int) -> float /{
    sub     esp,4

    mov     dword eax,$f1
    mov     dword [ebp - 4],eax
    fld     dword [ebp - 4]
    mov     dword eax,$n2
    mov     dword [ebp - 4],eax

    fidiv    dword [ebp - 4]
    fstp    dword [ebp - 4]
    mov     dword eax,[ebp - 4]

    add     esp,4
}/

pub native divf(n1: int, n2: int) -> float /{
    sub     esp,4

    mov     dword eax,$n1
    mov     dword [ebp - 4],eax
    fild    dword [ebp - 4]
    mov     dword eax,$n2
    mov     dword [ebp - 4],eax

    fidiv    dword [ebp - 4]
    fstp    dword [ebp - 4]
    mov     dword eax,[ebp - 4]

    add     esp,4
}/

pub native add(f1: float, f2: float) -> float /{
    sub     esp,4

    mov     dword eax,$f1
    mov     dword [ebp - 4],eax
    fld     dword [ebp - 4]
    mov     dword eax,$f2
    mov     dword [ebp - 4],eax

    fadd    dword [ebp - 4]
    fstp    dword [ebp - 4]
    mov     dword eax,[ebp - 4]

    add     esp,4
}/

pub native sub(f1: float, f2: float) -> float /{
    sub     esp,4

    mov     dword eax,$f1
    mov     dword [ebp - 4],eax
    fld     dword [ebp - 4]
    mov     dword eax,$f2
    mov     dword [ebp - 4],eax

    fsub    dword [ebp - 4]
    fstp    dword [ebp - 4]
    mov     dword eax,[ebp - 4]

    add     esp,4
}/

pub native add(f1: float, n2: int) -> float /{
    sub     esp,4

    mov     dword eax,$n2
    mov     dword [ebp - 4],eax
    fild    dword [ebp - 4]
    mov     dword eax,$f1
    mov     dword [ebp - 4],eax

    fadd    dword [ebp - 4]
    fstp    dword [ebp - 4]
    mov     dword eax,[ebp - 4]

    add     esp,4
}/

pub native sub(f1: float, n2: int) -> float /{
    sub     esp,4

    mov     dword eax,$f1
    mov     dword [ebp - 4],eax
    fld     dword [ebp - 4]
    mov     dword eax,$n2
    mov     dword [ebp - 4],eax

    fisub   dword [ebp - 4]
    fstp    dword [ebp - 4]
    mov     dword eax,[ebp - 4]

    add     esp,4
}/

pub native sub(n1: int, f2: float) -> float /{
    sub     esp,4

    mov     dword eax,$n1
    mov     dword [ebp - 4],eax
    fild    dword [ebp - 4]
    mov     dword eax,$f2
    mov     dword [ebp - 4],eax

    fsub   dword [ebp - 4]
    fstp    dword [ebp - 4]
    mov     dword eax,[ebp - 4]

    add     esp,4
}/

// false = 0 true = any other value
pub native greater(f1: float, f2: float) -> bool /{
    $call(cmp, $f1, $f2)
    cmp     dword eax,0
    je      .true
    mov     dword eax,0
    jmp     .end
.true:
    mov     dword eax,1
.end:
}/

pub native greater(f1: float, n2: int) -> bool /{
    $call(cmp, $f1, $n2)
    cmp     dword eax,0
    je      .true
    mov     dword eax,0
    jmp     .end
.true:
    mov     dword eax,1
.end:
}/

pub native less(f1: float, f2: float) -> bool /{
    $call(cmp, $f1, $f2)
    cmp     dword eax,0x100
    je      .true
    mov     dword eax,0
    jmp     .end
.true:
    mov     dword eax,1
.end:
}/

pub native less(f1: float, n2: int) -> bool /{
    $call(cmp, $f1, $n2)
    cmp     dword eax,0x100
    je      .true
    mov     dword eax,0
    jmp     .end
.true:
    mov     dword eax,1
.end:
}/

pub native cmp(f1: float, f2: float) -> int /{
    sub     esp,4

    finit

    mov     dword eax,$f1
    mov     dword [ebp - 4],eax
    fld     dword [ebp - 4]
    mov     dword eax,$f2
    mov     dword [ebp - 4],eax

    fcom    dword [ebp - 4]
    fstsw   [ebp - 4]
    mov     dword eax,[ebp - 4]
    and     dword eax,0x4500    ; c0 bit 8 (0 based), c2 bit 10, c3 bit 14

    finit

    add     esp,4
}/

pub native cmp(f1: float, n2: int) -> int /{
    sub     esp,4

    finit

    mov     dword eax,$f1
    mov     dword [ebp - 4],eax
    fld     dword [ebp - 4]
    mov     dword eax,$n2
    mov     dword [ebp - 4],eax

    ficom    dword [ebp - 4]
    fstsw   [ebp - 4]
    mov     dword eax,[ebp - 4]
    and     dword eax,0x4500    ; c0 bit 8 (0 based), c2 bit 10, c3 bit 14

    finit

    add     esp,4
}/

// false = 0 true = any other value
pub native min(f1: float, f2: float) -> float /{
    $call(greater, $f1: float, $f2: float)
    cmp     dword eax,0
    jz      .false
    mov     dword eax,$f2
    jmp     .end
.false:
    mov     dword eax,$f1
.end:
}/

pub native toString(n: float) -> str /{
    push    ebx
    push    ecx
    push    edx

    $call(rasmalloc, 20, " temp for toString(int)")
    push eax

    $call(addRef, eax, "")
    mov     dword eax,[eax]

    mov     dword edx, $n
    and     dword edx, 0x80000000
    jz      .mantissa
    mov     byte [eax],'-'
    inc     eax
    ; gotoOnSome .end
.mantissa:
    ; mantissa
    mov     dword edx, $n
    and     dword edx, 0x7FFFFF

    mov     dword ebx, $n
    and     dword ebx, 0x7F800000
    shr     dword ebx, 23
    cmp     dword ebx, 255
    jne     .defined
.undefined:
    ; TODO
    ; $call(print, $file, "undefined")
    jmp     .end
.defined:
    cmp     dword ebx, 0
    je      .denorm
    or      dword edx,0x800000
    cmp     dword ebx, 127
    jb      .below
    sub     ebx,126
    $call(printAligned, eax, edx, ebx)
    jmp      .end
.below:
    mov     dword ecx,126
    sub     dword ecx,ebx
    shr     edx,cl
    $call(printAligned, eax, edx, 0)
    jmp     .end
.denorm:
    $call(printAligned, eax, edx, 1)
.end:
    mov   byte  [eax], 0

    pop     eax
    pop     edx
    pop     ecx
    pop     ebx
}/

native printAligned(s: int, alignedMantissa: int, intNumbersCount: int) -> int /{
    push    ebx
    push    ecx
    mov     dword eax, $s

    mov     dword ecx, 24
    sub     dword ecx, $intNumbersCount
    mov     dword ebx, $alignedMantissa
    shr     dword ebx, cl

    $call(intToString, eax, ebx)

    mov     dword ebx, 1
    shl     dword ebx, cl
    dec     ebx
    and     ebx, $alignedMantissa
    $call(printDecimals, eax, ebx, ecx)

.end:
    pop     ecx
    pop     ebx
}/

native printDecimals(s: int, n: int, count: int) -> int /{
    ; local val for result
    sub     dword esp,4

    mov     dword eax,$s

    push    ebx
    push    ecx
    push    edx
    push    esi

    mov     dword esi,5             ; five_multiplier
    mov     dword ebx,0             ; temp_result
    mov     dword ecx,0             ; inner_count
    mov     dword edx,$count        ; actual_count
    mov     dword [ebp -4],0        ; result

.loop:
    cmp     dword edx,0
    jz      .end

    cmp     dword ecx, 9
    jne     .continue
    mov     dword [ebp -4], ebx
    mov     dword ebx,0
.continue:
    cmp     dword ecx,9
    jb      .continue2
    push    edx
    push    ecx
    mov     dword ecx,10
    xor     edx,edx

    push    eax
    mov     eax,esi

    div     ecx
    mov     esi,eax
    pop     eax
    pop     ecx
    pop     edx
    jmp     .continue3
.continue2:
    push    edx
    imul    dword ebx,10
    pop     edx
.continue3:
    push    eax
    $call(getNthBit, $n, edx)
    cmp     dword eax,0
    je      .continue4
    pop     eax
    add     dword ebx,esi
    jmp     .continue5
.continue4:
    pop     eax
.continue5:
    push    edx
    imul    dword esi,5
    pop     edx
    dec     edx
    inc     ecx
    jmp     .loop
.end:
    mov     dword esi,[ebp -4]                     ; result
    add     dword esi, ebx
    mov     dword ebx,esi
    mov     byte [eax],'.'
    inc     eax
    $call(printPadLeft, eax, ebx, '0': char, 9)

.end2:
    pop    esi
    pop    edx
    pop    ecx
    pop    ebx

    add    dword esp,4
}/

native printPadLeft(s: int, n: int, ch: char, count: int) -> int /{
    push    ebx
    push    ecx
    push    edx

    ; TODO we can optimize it, because we are running the toString and the len two times. Here only to calculate the length
    ; of the number, then in the intToString function
    $call(toString, $n)
    $call(len, eax: str)

    mov     dword ebx,$count
    sub     dword ebx,eax

    mov     dword eax, $s
    mov     ecx,$ch

.loop:
    cmp     dword ebx, 0
    jz      .end
    mov     byte [eax], cl
    inc     eax
    dec     dword ebx
    jmp     .loop
.end:
    $call(intToString, eax, $n)

    pop     edx
    pop     ecx
    pop     ebx
}/

/**
 *  "prints" an integer (n) to an address (s) that is a pointer (an assembly pointer, not rasm pointer) to a string.
 *  It returns the new address of the string
 */
native intToString(s: int, n: int) -> int /{
    push    ecx
    push    edx

    $call(toString, $n)
    mov     edx,eax
    $call(len, eax: str)
    mov     ecx, eax
    sub     dword ebx,eax
    mov     dword eax,$s

    $call(memcopy, [edx], eax, ecx)
    add     eax, ecx

    pop     edx
    pop     ecx
}/

// false = 0 true = any other value
// false if not valid
native getNthBit(value: int, n: int) -> bool /{
    push ecx

    mov     dword eax,1
    mov     dword ecx,$n
    dec     ecx
    shl     eax,cl
    and     dword eax,$value
    cmp     dword eax,0
    jz      .false
    mov     dword eax,1
    jmp     .end
.false:
    mov     dword eax,0
.end:
    pop     ecx
}/