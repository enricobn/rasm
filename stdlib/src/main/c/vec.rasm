pub type Vec<T> /{ hasReferences = true, nativeType = struct Vector* }/

native Vec(length: int, size: int) -> RasmPointer /{
    struct RasmPointer_ *result = rasmMalloc(sizeof(struct Vector));
    struct Vector *new_vec = (struct Vector*)result->address;
    new_vec->length = length;
    //if (length == 0) {
    //    new_vec->values = NULL;
    //} else {
        new_vec->values = rasmMalloc(size * length);
    //}
    return result;
}/

pub native VecAddRef<T>(address: Vec<T>) /{
    struct Vector *vector = $castAddress($address);

    if (vector->values != NULL) {
        addRef(vector->values);
        $realTypeName(T) *array = ($realTypeName(T) *)vector->values->address;

        if ($isRef(T)) {
            for (int i=0; i < vector->length; i++) {
                $addRef(array[i]: T)
            }
        }
    }
    addRef(address);
    // the C method returns Void_
    return NULL;
}/

pub native VecDeref<T>(address: Vec<T>) /{
    struct Vector *vector = $castAddress($address);

    // TODO remove this optimization, an empty Vec is created with values containing an empty array
    if (vector->values != NULL) {
        $realTypeName(T) *array = ($realTypeName(T) *)vector->values->address;

        if ($isRef(T)) {
            for (int i=0; i < vector->length; i++) {
                $deref(array[i]: T)
            }
        }

        deref(vector->values);
    }

    deref(address);
    // the C method returns Void_
    return NULL;
}/

pub native Vec<T>() -> Vec<T> /{
    size_t s = sizeof($realTypeName(T));
    return $call(Vec,0,s);
}/

pub native first<T>(vec: Vec<T>) -> Option<T> /{
    size_t length = $castAddress($vec)->length;

    if (length == 0) {
        $enumSimple(result,None)
        return result;
    } else {
        struct RasmPointer_ *values = $castAddress($vec)->values;
        $realTypeName(T) *array = ($realTypeName(T) *)values->address;
        $realTypeName(T) value = array[0];
        $addRef(value:T)
        return
        $call(Some, value:T)
        ;
    }
}/

pub native last<T>(vec: Vec<T>) -> Option<T> /{
    size_t length = $castAddress($vec)->length;

    if (length == 0) {
        $enumSimple(result,None)
        return result;
    } else {
        struct RasmPointer_ *values = $castAddress($vec)->values;
        $realTypeName(T) *array = ($realTypeName(T) *)values->address;
        $realTypeName(T) value = array[length - 1];
        $addRef(value:T)
        return
        $call(Some, value:T)
        ;
    }
}/

pub native push<T>(vec: Vec<T>, o: T) -> Vec<T> /{
    $include(<stdlib.h>)
    $include(<string.h>)

    size_t length = $castAddress($vec)->length;
    struct RasmPointer_ *values = $castAddress($vec)->values;
    $realTypeName(T) *array = ($realTypeName(T) *)values->address;

    size_t s = sizeof($realTypeName(T));
    struct RasmPointer_ *result = $call(Vec,length + 1,s);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    $realTypeName(T) *result_array = ($realTypeName(T) *)result_values->address;

    memcpy(result_array, array, s * length);

    result_array[length] = $o;
    return result;
}/

pub native len<T>(vec: Vec<T>) -> int /{
    return $castAddress($vec)->length;
}/

pub native vecOf<T>(o: T) -> Vec<T> /{
    size_t s = sizeof($realTypeName(T));
    struct RasmPointer_ *result = $call(Vec,1,s:int);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    $realTypeName(T) *result_array = ($realTypeName(T) *)result_values->address;

    result_array[0] = o;

    return result;
}/

pub native toVec<T>(iter: Iter<T>) -> Vec<T> /{
    long chunkSize = 50;
    size_t t_size = sizeof($realTypeName(T));
    struct RasmPointer_ *result = $call(Vec,chunkSize,t_size:int);
    long size = chunkSize;
    addRef(result);
    struct RasmPointer_ *iter_ = $iter;
    // $addRef(iter_:Iter<T>)
    long i = 0;
    while (1) {
        struct RasmPointer_ *optValue =
            $call(callNext, iter_:Iter<T>)
        ;
        $addRef(optValue:Option<IterValue<T>>)
        struct Enum *e = (struct Enum *) optValue->address;
        if (e->variant_num == 0) {
            $enumVariant(s,Some,optValue:Option<IterValue<T>>)
            struct RasmPointer_ *iterValue = s->value;
            struct RasmPointer_ *tmp_iter = 
                $call(next, iterValue:IterValue<T>)
            ;
            // $deref(iter_:Iter<T>)
            iter_ = tmp_iter;
            // $addRef(iter_:Iter<T>)
            if (i == size) {
                size += chunkSize;
                struct RasmPointer_ *newResult = $call(Vec,size,t_size:int);
                addRef(newResult);

                struct Vector *result_vec = (struct Vector*)result->address;
                struct Vector *newResult_vec = (struct Vector*)newResult->address;

                memcpy(newResult_vec->values->address, result_vec->values->address, (size - chunkSize) * t_size);

                deref(result);

                result = newResult;
            }
            struct Vector *result_vec = (struct Vector*)result->address;
            $realTypeName(T) *result_array = ($realTypeName(T) *)result_vec->values->address;
            $realTypeName(T) v = 
                $call(value, iterValue:IterValue<T>)
            ;
            result_array[i] = v;
            $addRef(v:T)
            i++;
        } else {
            break;
        }
        $deref(optValue:Option<IterValue<T>>);
    }
    // $deref(iter_:Iter<T>)
    //$deref(result:Vec<T>);
    deref(result);
    struct Vector *result_vec = (struct Vector*)result->address;
    result_vec->length = i;
    return result;
}/

pub native vecOf<T>(o1: T, o2: T) -> Vec<T> /{
    size_t s = sizeof($realTypeName(T));
    struct RasmPointer_ *result = $call(Vec,2,s);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    $realTypeName(T) *result_array = ($realTypeName(T) *)result_values->address;

    result_array[0] = o1;
    result_array[1] = o2;

    return result;
}/

pub native vecOf<T>(o1: T, o2: T, o3: T) -> Vec<T> /{
    size_t s = sizeof($realTypeName(T));
    struct RasmPointer_ *result = $call(Vec,3,s:int);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    $realTypeName(T) *result_array = ($realTypeName(T) *)result_values->address;

    result_array[0] = o1;
    result_array[1] = o2;
    result_array[2] = o3;

    return result;
}/

pub native vecOf<T>(o1: T, o2: T, o3: T, o4: T) -> Vec<T> /{
    size_t s = sizeof($realTypeName(T));
    struct RasmPointer_ *result = $call(Vec, 4,s:int);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    $realTypeName(T) *result_array = ($realTypeName(T) *)result_values->address;

    result_array[0] = o1;
    result_array[1] = o2;
    result_array[2] = o3;
    result_array[3] = o4;

    return result;
}/

pub native vecOf<T>(o1: T, o2: T, o3: T, o4: T, o5: T) -> Vec<T> /{
    size_t s = sizeof($realTypeName(T));
    struct RasmPointer_ *result = $call(Vec, 5,s:int);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    $realTypeName(T) *result_array = ($realTypeName(T) *)result_values->address;

    result_array[0] = o1;
    result_array[1] = o2;
    result_array[2] = o3;
    result_array[3] = o4;
    result_array[4] = o5;

    return result;
}/

pub native vecOf<T>(o1: T, o2: T, o3: T, o4: T, o5: T, o6: T, o7: T, o8: T) -> Vec<T> /{
    size_t s = sizeof($realTypeName(T));
    struct RasmPointer_ *result = $call(Vec,8,s:int);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    $realTypeName(T) *result_array = ($realTypeName(T) *)result_values->address;

    result_array[0] = o1;
    result_array[1] = o2;
    result_array[2] = o3;
    result_array[3] = o4;
    result_array[4] = o5;
    result_array[5] = o6;
    result_array[6] = o7;
    result_array[7] = o8;

    return result;
}/

native optIOError() -> Option<IOError> /{
    $include(<errno.h>)

    if (errno == 0) {
        $enumSimple(result,None)
        return result;
    } else {
        void *error = $call(IOError, "IO Error");
        return $call(Some, error: IOError);
    }
}/

/*
TODO it does not addRef/deref in call print of single element, so for now, we use the non native implementation
pub native print<T>(file: File, vec: Vec<T>) -> Option<IOError> /{
    $include(<stdio.h>)

    size_t length = $castAddress($vec)->length;
    struct RasmPointer_ *values = $castAddress($vec)->values;
    void **array = (void **)values->address;

    errno = 0;

    for (int i = 0; i < length; i++) {
        $call(print, file: File, array[i]:T)
        fprintf(file, ",");
    }
    return $call(optIOError);
}/
*/

// end exclusive
pub native vecRange(start: int, end: int) -> Vec<int> /{
    $include(<stdlib.h>)

    size_t length = end-start;

    size_t s = sizeof(long);
    struct RasmPointer_ *result = $call(Vec,length,s);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    long *result_array = (long *)result_values->address;

    int counter = 0;
    for (long i = start; i < end; i++) {
        result_array[counter++] = i;
    }

    return result;
}/

pub native map<T,T1>(vec: Vec<T>, f: fn(T) -> T1) -> Vec<T1>/{
    size_t length = $castAddress($vec)->length;
    struct RasmPointer_ *values = $castAddress($vec)->values;
    $realTypeName(T) *array = ($realTypeName(T) *)values->address;

    size_t s = sizeof($realTypeName(T1));
    struct RasmPointer_ *result = $call(Vec,length,s:int);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    $realTypeName(T1) *result_array = ($realTypeName(T1) *)result_values->address;

    addRef(result);
    addRef(result_values);

    for (int i = 0; i < length; i++) {
        $realTypeName(T1) tmp = $castAddress($f)->functionPtr(array[i], f);
        $addRef(tmp:T1)
        result_array[i] = tmp;
    }

    $deref(result:Vec<T1>)
    return result;
}/

// false 0 true 1
pub native anyMatch<T>(vec: Vec<T>, f: fn(T) -> bool) -> bool /{
    size_t length = $castAddress($vec)->length;
    struct RasmPointer_ *values = $castAddress($vec)->values;
    $realTypeName(T) *array = ($realTypeName(T) *)values->address;
    
    for (int i = 0; i < length; i++) {
        if ($castAddress($f)->functionPtr(array[i], f)) {
            return 1;
        }
    }

    return 0;
}/

// false 0 true 1
pub native allMatch<T>(vec: Vec<T>, f: fn(T) -> bool) -> bool /{
    size_t length = $castAddress($vec)->length;
    struct RasmPointer_ *values = $castAddress($vec)->values;
    $realTypeName(T) *array = ($realTypeName(T) *)values->address;
    
    for (int i = 0; i < length; i++) {
        if (!$castAddress($f)->functionPtr(array[i], f)) {
            return 0;
        }
    }

    return 1;
}/

pub native count<T>(vec: Vec<T>, f: fn(T) -> bool) -> int /{
    size_t length = $castAddress($vec)->length;
    struct RasmPointer_ *values = $castAddress($vec)->values;
    $realTypeName(T) *array = ($realTypeName(T) *)values->address;

    int result = 0;
    for (int i = 0; i < length; i++) {
        if ($castAddress($f)->functionPtr(array[i], f)) {
            result++;
        }
    }

    return result;
}/

pub native filter<T>(vec: Vec<T>, filter: fn(T) -> bool) -> Vec<T> /{
    size_t length = $castAddress($vec)->length;
    struct RasmPointer_ *values = $castAddress($vec)->values;
    $realTypeName(T) *array = ($realTypeName(T) *)values->address;

    size_t s = sizeof($realTypeName(T));
    struct RasmPointer_ *result = $call(Vec,length,s:int);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    $realTypeName(T) *result_array = ($realTypeName(T) *)result_values->address;

    int dest_1 = 0;
    for (int i = 0; i < length; i++) {
        if ($castAddress($filter)->functionPtr(array[i], filter)) {
            result_array[dest_1++] = array[i];
        }
    }

    result_vec->length = dest_1;

    return result;
}/

pub native zip<T1,T2,T>(vec1: Vec<T1>, vec2: Vec<T2>, zipFunction: fn(T1, T2) -> T) -> Vec<T> /{
    size_t length1 = $castAddress($vec1)->length;
    struct RasmPointer_ *values1 = $castAddress($vec1)->values;
    $realTypeName(T1) *array1 = ($realTypeName(T1) *)values1->address;

    size_t length2 = $castAddress($vec2)->length;
    struct RasmPointer_ *values2 = $castAddress($vec2)->values;
    $realTypeName(T2) *array2 = ($realTypeName(T2) *)values2->address;

    int length = length2;
    if (length1 < length2) {
        length = length1;
    }

    size_t s = sizeof($realTypeName(T));
    struct RasmPointer_ *result = $call(Vec,length,s);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    $realTypeName(T) *result_array = ($realTypeName(T) *)result_values->address;

    addRef(result);
    addRef(result_values);

    for (int i = 0; i < length; i++) {
        $realTypeName(T) tmp = $castAddress($zipFunction)->functionPtr(array1[i], array2[i], zipFunction);
        $addRef(tmp:T)
        result_array[i] = tmp;
    }

    $deref(result:Vec<T>)

    return result;
}/

pub native add<T>(vec1: Vec<T>, vec2: Vec<T>) -> Vec<T> /{
    $include(<string.h>)

    size_t length1 = $castAddress($vec1)->length;
    struct RasmPointer_ *values1 = $castAddress($vec1)->values;
    $realTypeName(T) *array1 = ($realTypeName(T) *)values1->address;

    size_t length2 = $castAddress($vec2)->length;
    struct RasmPointer_ *values2 = $castAddress($vec2)->values;
    $realTypeName(T) *array2 = ($realTypeName(T) *)values2->address;

    size_t s = sizeof($realTypeName(T));
    struct RasmPointer_ *result = $call(Vec,length1 + length2, s);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    $realTypeName(T) *result_array = ($realTypeName(T) *)result_values->address;

    memcpy(result_array, array1, s * length1);

    $realTypeName(T) *vec1_pos = result_array + length1;

    memcpy(vec1_pos, array2, s * length2);

    return result;
}/

pub native flatten<T>(vec: Vec<Vec<T>>) -> Vec<T> /{
    size_t s = sizeof($realTypeName(T));
    size_t length = $castAddress($vec,s)->length;
    struct RasmPointer_ *values = $castAddress($vec)->values;
    void **array = (void **)values->address;

    size_t new_length = 0;
    for (int i = 0; i < length; i++) {
        struct Vector *innerVec = (struct Vector *)((struct RasmPointer_*)array[i])->address;
        int inner_lenght = innerVec->length;

        new_length += inner_lenght;
    }

    struct RasmPointer_ *result = $call(Vec,new_length,s);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    $realTypeName(T) *result_array = ($realTypeName(T) *)result_values->address;

    int dest_i = 0;
    for (int i = 0; i < length; i++) {
        struct Vector *innerVec = (struct Vector *)((struct RasmPointer_*)array[i])->address;
        int inner_lenght = innerVec->length;
        struct RasmPointer_ *inner_values = innerVec->values;
        $realTypeName(T) *inner_array = ($realTypeName(T) *) inner_values->address;

        memcpy(result_array + dest_i, inner_array, inner_lenght * s);
        dest_i += inner_lenght;
    }

    return result;
}/

pub native foldLeft<T,T1>(vec: Vec<T>, zero: T1, accum: fn(T1,T) -> T1) -> T1 /{
    size_t length = $castAddress($vec)->length;
    struct RasmPointer_ *values = $castAddress($vec)->values;
    $realTypeName(T) *array = ($realTypeName(T) *)values->address;

    $realTypeName(T1) result = zero;

    for (int i = 0; i < length; i++) {
        $addRef(result: T1)
        $realTypeName(T1) tmpResult = $castAddress($accum)->functionPtr(result, array[i], accum);
        $deref(result: T1)
        result = tmpResult;
    }

    return result;
}/

pub native charsVec(s: str) -> Vec<char> /{
    $include(<stdlib.h>)

    int length = 
    $call(len, $s)
    size_t sz = sizeof(void *);
    struct RasmPointer_ *result = $call(Vec,length,sz);
    struct Vector *result_vec = (struct Vector*)result->address;
    struct RasmPointer_ *result_values = result_vec->values;
    void **result_array = (void **)result_values->address;

    char *s_ = (char *)$s->address;

    int len = strlen(s_);
    int i = 0;
    int count = 0;

    while (i < len) {
        char lb = s_[i];
        char *c;
        struct RasmPointer_ *c_;
        if (( lb & 0x80 ) == 0 ) {         // lead bit is zero, must be a single ascii
           c_ = rasmMalloc(sizeof(char) * 2);
           c = (char*)c_->address;
           c[0] = lb;
           c[1] = 0;
           i += 1;
        } else if (( lb & 0xE0 ) == 0xC0 ) { // 110x xxxx
          c_ = rasmMalloc(sizeof(char) * 3);
          c = (char*)c_->address;
          c[0] = lb;
          c[1] = s_[i + 1];
          c[2] = 0;
          i += 2;
        } else if (( lb & 0xF0 ) == 0xE0 ) { // 1110 xxxx
          c_ = rasmMalloc(sizeof(char) * 4);
          c = (char*)c_->address;
          c[0] = lb;
          c[1] = s_[i + 1];
          c[2] = s_[i + 2];
          c[3] = 0;
          i += 3;
        } else if (( lb & 0xF8 ) == 0xF0 ) { // 1111 0xxx
          c_ = rasmMalloc(sizeof(char) * 5);
          c = (char*)c_->address;
          c[0] = lb;
          c[1] = s_[i + 1];
          c[2] = s_[i + 2];
          c[3] = s_[i + 3];
          c[4] = 0;
          i += 4;
        } else {
           printf( "Unrecognized lead byte (%02x)\n", lb );
           return result;
       }
       $addRef(c_:char)
       result_array[count++] = c_;
    }
    return result;
}/

pub native forEach<T>(vec: Vec<T>, f: fn(T) -> ()) /{
    size_t length = $castAddress($vec)->length;
    struct RasmPointer_ *values = $castAddress($vec)->values;
    $realTypeName(T) *array = ($realTypeName(T) *)values->address;

    for (int i = 0; i < length; i++) {
        $castAddress($f)->functionPtr(array[i], f);
    }
}/

pub native get<T>(vec: Vec<T>, i: int) -> Option<T> /{
    int l = $castAddress($vec)->length;
    if (i >= l || i < 0) {
        $enumSimple(result,None);
        return result;
    } else {
        struct RasmPointer_ *array_values = $castAddress($vec)->values;           \
        $realTypeName(T) *array = ($realTypeName(T) *)array_values->address;     \
        $realTypeName(T) value = array[i];

        //$addRef(value:T)
        return $call(Some, value: T);
    }
}/

native getUnsafe<T>(vec: Vec<T>, i: int) -> T /{
    struct RasmPointer_ *array_values = $castAddress($vec)->values;           \
    $realTypeName(T) *array = ($realTypeName(T) *)array_values->address;     \
    return array[i];
}/

pub fn iter<T>(o: Vec<T>) -> Iter<T> {
    iter(o, 0);
}

fn iter<T>(o: Vec<T>, index: int) -> Iter<T> {
    if(o.len.greater(index),
        Iter({ Some(IterValue(o.getUnsafe(index), iter(o, index.add(1)))); }),
        emptyIter()
    );
}