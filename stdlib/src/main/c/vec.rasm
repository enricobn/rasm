/*
the structure of vec
    int length;
    void **values;
*/
pub type Vec<T>(true, "void **");

pub fn VecReferences(vec: RasmPointer, generic: i32) -> RasmPointer {
    vec;
}

pub native Vec<T>() -> Vec<T> /{
    $include(<stdlib.h>)

    void **result = rasmMalloc(sizeof(void *) * 2);
    int* length = rasmMalloc(sizeof(int));
    *length = 0;
    result[0] = length;
    result[1] = NULL;
    return result;
}/

pub native first<T>(vec: Vec<T>) -> Option<T> /{
    int length = *((int*)$vec[0]);

    if (length == 0) {
        $enumDeclaration(result)
        $enumVariantDeclaration(none,None)
        result->variant_num = 1;
        result->variant = none;
        return result;
    } else {
        void **array = $vec[1];
        void *value = array[0];
        $addRef(value:T)
        return
        $call(Option::Some, value:T)
        ;
    }
}/

pub native last<T>(vec: Vec<T>) -> Option<T> /{
    int length = *((int*)$vec[0]);

    if (length == 0) {
        $enumDeclaration(result)
        $enumVariantDeclaration(none,None)
        result->variant_num = 1;
        result->variant = none;
        return result;
    } else {
        void **array = $vec[1];
        void *value = array[length - 1];
        $addRef(value:T)
        return
        $call(Option::Some, value:T)
        ;
    }
}/

pub native push<T>(vec: Vec<T>, o: T) -> Vec<T> /{
    $include(<stdlib.h>)
    $include(<string.h>)

    void **old_vec = vec;
    void **result = rasmMalloc(sizeof(void *) * 2);

    int old_length = *((int*)old_vec[0]);

    int *new_length = rasmMalloc(sizeof(int));
    *new_length = old_length + 1;

    result[0] = new_length;
    result[1] = rasmMalloc(sizeof(void *) * (old_length + 1));

    void **old_array = old_vec[1];
    void **array = result[1];

    memcpy(array, old_array, sizeof(void *) * old_length);

    array[old_length] = $o;
    return result;
}/

pub native len<T>(vec: Vec<T>) -> i32 /{
    return *(int*)(vec[0]);
}/

pub native vecOf<T>(o: T) -> Vec<T> /{
    void **result = $call(vecOfInternal, 1, $o);

    void **vec = result[1];
    vec[0] = o;

    return result;
}/

pub native vecOf<T>(o1: T, o2: T) -> Vec<T> /{
    void **result = $call(vecOfInternal, 2, $o1);

    void **vec = result[1];
    vec[0] = o1;
    vec[1] = o2;

    return result;
}/

pub native vecOf<T>(o1: T, o2: T, o3: T) -> Vec<T> /{
    void **result = $call(vecOfInternal, 3, $o1);

    void **vec = result[1];
    vec[0] = o1;
    vec[1] = o2;
    vec[2] = o3;

    return result;
}/

pub native vecOf<T>(o1: T, o2: T, o3: T, o4: T, o5: T, o6: T, o7: T, o8: T) -> Vec<T> /{
    void **result = $call(vecOfInternal, 8, $o1);

    void **vec = result[1];
    vec[0] = o1;
    vec[1] = o2;
    vec[2] = o3;
    vec[3] = o4;
    vec[4] = o5;
    vec[5] = o6;
    vec[6] = o7;
    vec[7] = o8;

    return result;
}/

// o is used to determine the type
native vecOfInternal<T>(len: i32, o: T) -> Vec<T> /{
    $include(<stdlib.h>)

    void **result = rasmMalloc(sizeof(void *) * 2);

    int *length = rasmMalloc(sizeof(int));
    *length = len;

    void **vec = rasmMalloc(sizeof(void *) * len);

    result[0] = length;
    result[1] = vec;
    return result;
}/

native optIOError() -> Option<IOError> /{
    $include(<errno.h>)

    if (errno == 0) {
        $enumDeclaration(result)
        $enumVariantDeclaration(none,None)
        result->variant_num = 1;
        result->variant = none;
        return result;
    } else {
        void *error = $call(IOError, "IO Error");
        return $call(Option::Some, error: IOError);
    }
}/

pub native print<T>(file: File, v: Vec<T>) -> Option<IOError> /{
    $include(<stdio.h>)

    int length = *(int*)$v[0];
    void **args = $v[1];

    errno = 0;

    for (int i = 0; i < length; i++) {
        $call(print, file: File, args[i]:T)
        fprintf(file, ",");
    }
    return $call(optIOError);
}/

// end exclusive
pub native vecRange(start: i32, end: i32) -> Vec<i32> /{
    $include(<stdlib.h>)

    void **result = rasmMalloc(sizeof(void *) * 2);

    int *length = rasmMalloc(sizeof(int));
    *length = end - start;

    void **vec = rasmMalloc(sizeof(void *) * *length);

    int counter = 0;
    for (int i = start; i < end; i++) {
        vec[counter++] = i;
    }
    result[0] = length;
    result[1] = vec;

    return result;
}/

pub native map<T,T1>(vec: Vec<T>, f: fn(T) -> T1) -> Vec<T1>/{
    int old_length = *(int *)vec[0];

    int *length = rasmMalloc(sizeof(int));
    $call(addRef, length:RasmPointer)
    *length = old_length;

    void **result = rasmMalloc(sizeof(void *) * 2);
    $call(addRef, result:RasmPointer)
    void **vec_ = rasmMalloc(sizeof(void *) * old_length);
    $call(addRef, vec_:RasmPointer)

    result[0] = length;
    result[1] = vec_;

    for (int i = 0; i < old_length; i++) {
        void *tmp = f->functionPtr(((void **)vec[1])[i], f);
        $addRef(tmp:T1)
        vec_[i] = tmp;
    }

    $deref(result:Vec<T1>)
    return result;
}/

// false 0 true 1
pub native anyMatch<T>(vec: Vec<T>, f: fn(T) -> bool) -> bool /{
    int length = *(int *)vec[0];

    void **vec_ = (void **)vec[1];

    for (int i = 0; i < length; i++) {
        if (f->functionPtr(vec_[i], f)) {
            return 1;
        }
    }

    return 0;
}/

pub native count<T>(vec: Vec<T>, f: fn(T) -> bool) -> i32 /{
    int length = *(int *)vec[0];

    void **vec_ = (void **)vec[1];

    int result = 0;
    for (int i = 0; i < length; i++) {
        if (f->functionPtr(vec_[i], f)) {
            result++;
        }
    }

    return result;
}/

pub native filter<T>(vec: Vec<T>, filter: fn(T) -> bool) -> Vec<T> /{
    int original_length = *(int *)vec[0];

    void **result = rasmMalloc(sizeof(void *) * 2);
    int* length = rasmMalloc(sizeof(int));

    void **old_vec = (void **) vec[1];
    void **new_vec = rasmMalloc(sizeof(void *) * original_length);

    int dest_1 = 0;
    for (int i = 0; i < original_length; i++) {
        if (filter->functionPtr(old_vec[i], filter)) {
            new_vec[dest_1++] = old_vec[i];
        }
    }

    *length = dest_1;

    result[0] = length;
    result[1] = new_vec;
    return result;
}/

pub native zip<T1,T2,T>(vec1: Vec<T1>, vec2: Vec<T2>, zipFunction: fn(T1, T2) -> T) -> Vec<T> /{
    int length1 = *(int *)vec1[0];
    int length2 = *(int *)vec2[0];

    int length = length2;
    if (length1 < length2) {
        length = length1;
    }

    void **result = rasmMalloc(sizeof(void *) * 2);
    void **vec = rasmMalloc(sizeof(void *) * length);
    int *length_ = rasmMalloc(sizeof(int));
    *length_ = length;
    result[0] = length_;
    result[1] = vec;
    $call(addRef, result:RasmPointer)

    for (int i = 0; i < length; i++) {
        void *tmp = zipFunction->functionPtr(((void **)vec1[1])[i], ((void **)vec2[1])[i], zipFunction);
        $addRef(tmp:T)
        vec[i] = tmp;
    }

    $call(deref, result:RasmPointer)

    return result;
}/

pub native add<T>(vec1: Vec<T>, vec2: Vec<T>) -> Vec<T> /{
    $include(<string.h>)

    int length1 = *(int *)vec1[0];
    int length2 = *(int *)vec2[0];

    void **result = rasmMalloc(sizeof(void *) * 2);
    int* length = rasmMalloc(sizeof(int));
    *length = length1 + length2;
    result[0] = length;

    void **vec = rasmMalloc(sizeof(void *) * (length1 + length2));

    memcpy(vec, vec1[1], sizeof(void *) * length1);

    void **vec1_pos = vec + length1;

    memcpy(vec1_pos, vec2[1], sizeof(void *) * length2);
    result[1] = vec;

    return result;
}/

pub native flatten<T>(vec: Vec<Vec<T>>) -> Vec<T> /{
    int length = 0;
    void **vec_ = (void **)vec[1];

    for (int i = 0; i < *(int *)vec[0]; i++) {
        void **innerVec = vec_[i];
        length += *(int *)innerVec[0];
    }

    void **result = rasmMalloc(sizeof(void *) * 2);
    void **result_vec = rasmMalloc(sizeof(void *) * length);
    int *_length = rasmMalloc(sizeof(int));
    *_length = length;
    result[0] = _length;
    result[1] = result_vec;

    int dest_i = 0;
    for (int i = 0; i < *(int *)vec[0]; i++) {
        void **innerVec = vec_[i];
        int inner_lenght = *(int *)innerVec[0];
        memcpy(result_vec + dest_i, innerVec[1], inner_lenght * sizeof(void *));
        dest_i += inner_lenght;
    }

    return result;
}/

pub native foldLeft<T,T1>(vec: Vec<T>, zero: T1, accum: fn(T1,T) -> T1) -> T1 /{
    void *result = zero;
    int length = *(int *)vec[0];
    void **vec_ = (void **)vec[1];

    for (int i = 0; i < length; i++) {
        $addRef(result: T1)
        void *tmpResult = accum->functionPtr(result, vec_[i], accum);
        $deref(result: T1)
        result = tmpResult;
    }

    return result;
}/

pub native charsVec(s: str) -> Vec<char> /{
    $include(<stdlib.h>)

    void **result = rasmMalloc(sizeof(void *) * 2);
    int* length = rasmMalloc(sizeof(int));
    result[0] = length;
    result[1] = NULL;

    *length =
        $call(len, $s)
    ;
    void **vec = rasmMalloc(sizeof(void *) * *length);

    result[1] = vec;

    int len = strlen(s);
    int i = 0;
    int count = 0;

    while (i < len) {
        char lb = s[i];
        char *c;
        if (( lb & 0x80 ) == 0 ) {         // lead bit is zero, must be a single ascii
           c = rasmMalloc(sizeof(char) * 2);
           c[0] = lb;
           c[1] = 0;
           i += 1;
        } else if (( lb & 0xE0 ) == 0xC0 ) { // 110x xxxx
          c = rasmMalloc(sizeof(char) * 3);
          c[0] = lb;
          c[1] = s[i + 1];
          c[2] = 0;
          i += 2;
        } else if (( lb & 0xF0 ) == 0xE0 ) { // 1110 xxxx
          c = rasmMalloc(sizeof(char) * 4);
          c[0] = lb;
          c[1] = s[i + 1];
          c[2] = s[i + 2];
          c[3] = 0;
          i += 3;
        } else if (( lb & 0xF8 ) == 0xF0 ) { // 1111 0xxx
          c = rasmMalloc(sizeof(char) * 5);
          c[0] = lb;
          c[1] = s[i + 1];
          c[2] = s[i + 2];
          c[3] = s[i + 3];
          c[4] = 0;
          i += 4;
        } else {
           printf( "Unrecognized lead byte (%02x)\n", lb );
           return result;
       }
       vec[count++] = c;
    }
    return result;
}/

pub native forEach<T>(vec: Vec<T>, f: fn(T) -> ()) /{
    int length = *(int *)vec[0];

    for (int i = 0; i < length; i++) {
        f->functionPtr(((void **)vec[1])[i], f);
    }
}/