pub  native eq(a: char, b: char) -> bool /{
    $include(<string.h>)
    $inline()

    return (strcmp($a->address, $b->address) == 0);
}/

// from https://stackoverflow.com/questions/8465006/how-do-i-concatenate-two-strings-in-c
pub native add(s1: str, s2: str) -> str /{
    $include(<stdlib.h>)
    $include(<string.h>)

    char* s1_ = (char *)$s1->address;
    char* s2_ = (char *)$s2->address;

    int len_ = strlen(s1_) + strlen(s2_);

    struct RasmPointer_ *result = rasmMalloc(sizeof(char) * (len_ + 1)); // +1 for the null-terminator
    // in real code you would check for errors in malloc here
    strcpy(result->address, s1_);
    strcat(result->address, s2_);
    ((char *)result->address)[len_] = 0;
    return result;
}/

pub native add(s: str, c: char) -> str /{
    $include(<stdlib.h>)
    $include(<string.h>)

    char* s_ = (char *)$s->address;

    int len_ = strlen(s_) + strlen($c);

    struct RasmPointer_ *result = rasmMalloc(sizeof(char) * (len_ + 1)); // +1 for the null-terminator
    // in real code you would check for errors in malloc here
    strcpy(result->address, s_);
    strcat(result->address, $c->address);
    ((char *)result->address)[len_] = 0;
    return result;
}/

// from https://stackoverflow.com/questions/26080829/detecting-strtol-failure
pub native toInt(s: str) -> Option<int> /{
    $include(<errno.h>)

    char *end = NULL;
    char* s_ = (char *)$s->address;

    errno = 0;
    int result = (int) strtol(s_, &end, 10);

    if (errno == 0 && s_ && !*end) {
        return
        $call(Some, result)
        ;
    } else {
        // a "typed" None based on the typed return value of the function
        $enumSimple(result,None)
        return result;
    }
}/

pub native eq(s1: str, s2: str) -> bool /{
    $include(<string.h>)
    $inline()

    char* s1_ = (char *)$s1->address;
    char* s2_ = (char *)$s2->address;

    return (strcmp(s1_, s2_) == 0);
}/

// TODO does it work for UTF-8?
pub native less(s1: str, s2: str) -> bool /{
    $include(<string.h>)
    $inline()

    char* s1_ = (char *)$s1->address;
    char* s2_ = (char *)$s2->address;

    return (strcmp(s1_, s2_) < 0);
}/

// TODO does it work for UTF-8?
pub native greater(s1: str, s2: str) -> bool /{
    $include(<string.h>)
    $inline()

    char* s1_ = (char *)$s1->address;
    char* s2_ = (char *)$s2->address;

    return (strcmp(s1_, s2_) > 0);
}/

pub native len(s: str) -> int /{
    $include(<string.h>)

    char* s_ = (char *)$s->address;

    int len_ = strlen(s_);
    int i = 0;
    int count = 0;
    while (i < len_) {
        char lb = s_[i];
        if (( lb & 0x80 ) == 0 ) {         // lead bit is zero, must be a single ascii
           i += 1;
           count += 1;
        } else if (( lb & 0xE0 ) == 0xC0 ) { // 110x xxxx
          i += 2;
          count += 1;
        } else if (( lb & 0xF0 ) == 0xE0 ) { // 1110 xxxx
          i += 3;
          count += 1;
        } else if (( lb & 0xF8 ) == 0xF0 ) { // 1111 0xxx
          i += 4;
          count += 1;
        } else {
           printf( "Unrecognized lead byte (%02x)\n", lb );
           return -1;
       }
    }
    return count;
}/

// from https://stackoverflow.com/questions/2114377/copying-a-part-of-a-string-substring-in-c
// TODO it does not work for UTF-8
pub native substr(s: str, pos: int, len: int) -> Option<str> /{
    $include(<stdlib.h>)
    $include(<string.h>)

    char* s_ = (char *)$s->address;

    int input_len = strlen (s_);

    if (pos + len > input_len)
    {
        // a "typed" None based on the typed return value of the function
        $enumSimple(result,None)
        return result;
    }

    struct RasmPointer_ *dest = rasmMalloc((sizeof(char)) * len + 1);

    strncpy(dest->address, s_ + pos, len);
    ((char *)dest->address)[len] = 0;

    return $call(Some, dest:str);
}/

pub native isAlpha(c: char) -> bool /{
    $inline()
    char *c_ = (char *)c->address;
    return ((c_[0] >= 'a' && c_[0] <= 'z') || (c_[0] >= 'A' && c_[0] <= 'Z'));
}/

pub native isNumber(c: char) -> bool /{
    $inline()
    char *c_ = (char *)c->address;
    return (c_[0] >= '0' && c_[0] <= '9');
}/