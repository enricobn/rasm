inline asm if<T>(cond: bool, ftrue: fn() -> T, ffalse: fn() -> T) -> T /{
    mov     eax,$cond
    cmp     eax, 0
    jz      $+18
    mov     eax, $ftrue     ; ftrue points to the lambda space
    mov     dword eax,[eax]
    push    eax             ; the address to the lambda space is the last argument of every lambda
    call    [eax]           ; in the first 4 bytes of the lambda space there is the address of the lambda function to call
    add     esp, 4
    jmp     $+18
    nop
    nop
    nop
    mov     eax, $ffalse    ; ffalse points to the lambda space, we do the same as above
    mov     dword eax,[eax]
    push    eax
    call    [eax]           ; false value
    add     esp, 4
    nop
    nop
    nop
}/

fn if<T>(cond: bool, ftrue: fn() -> T, elseIfCond: bool, fElseIf: fn() -> T, ffalse: fn() -> T) -> T {
    if(cond, ftrue, { -> if(elseIfCond, fElseIf, ffalse); });
}

inline asm ifRun(cond: bool, ftrue: fn() -> (), ffalse: fn() -> ()) /{
    mov     eax,$cond
    cmp     eax, 0
    jz      $+18
    mov     eax, $ftrue     ; ftrue points to the lambda space
    mov     dword eax,[eax]
    push    eax             ; the address to the lambda space is the last argument of every lambda
    call    [eax]           ; in the first 4 bytes of the lambda space there is the address of the lambda function to call
    add     esp, 4
    jmp     $+18
    nop
    nop
    nop
    mov     eax, $ffalse    ; ffalse points to the lambda space, we do the same as above
    mov     dword eax,[eax]
    push    eax
    call    [eax]           ; false value
    add     esp, 4
    nop
    nop
    nop
}/

/**
    false = 0 true = 1
    it's a branch less implementation

    ATTENTION: it is not short circuit, it always evaluates both arguments,
    if you need a short circuit then use the version with lambda
**/
inline asm if<T>(cond: bool, trueVal: T, falseVal: T) -> T /{
    push  ebx
    push  edx

    mov   dword eax, $cond
    imul  dword eax, $trueVal
    mov   dword ebx, $cond
    xor   dword ebx, 1
    imul  dword ebx, $falseVal
    add   dword eax, ebx

    pop   edx
    pop   ebx
}/

/**
    ATTENTION: it is not short circuit, it always evaluates both arguments,
    if you need a short circuit then use the version with lambda
**/
fn if<T>(cond: bool, trueValue: T, elseIfCond: bool, valueElseIf: T, valueElse: T) -> T {
    if(cond, trueValue, if(elseIfCond, valueElseIf, valueElse));
}

/**
    false = 0 true = any other value

    ATTENTION: it is not completely short circuit, the true value is always evaluated,
    if you need a short circuit then use if function with lambda
**/
inline asm if<T>(cond: bool, vtrue: T, ffalse: fn() -> T) -> T /{
    mov     eax,$cond
    cmp     eax, 0
    jz      $+10
    mov     eax, $vtrue
    jmp     $+16
    nop     ; nops are used because it's inlined and $vtrue could be an immediate value or an address so we don't know where to jump exactly...
    nop
    nop
    mov     eax, $ffalse
    mov     dword eax,[eax]
    push    eax
    call    [eax]
    add     dword esp, 4
}/

/**
 *  a  <= b
 *  false = 0 true = 1
 **/
inline asm lessOrEqual(a: i32, b: i32) -> bool /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    jbe     $+7  ; Jump if Below or Equal unsigned comparison
    mov     eax,0 ; false
}/

/**
 *  a  < b
 *  false = 0 true = 1
 **/
inline asm less(a: i32, b: i32) -> bool /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    jl     $+7
    mov     eax,0 ; false
}/

/**
 *  a  <= b
 *  false = 0 true = 1
 **/
inline asm greater(a: i32, b: i32) -> bool /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    jg      $+7  ; Jump if greater unsigned comparison
    mov     eax,0 ; false
}/

/**
 *  a  == b
 *  false = 0 true = 1
 **/
inline asm eq(a: i32, b: i32) -> bool /{
    mov     eax,$a
    cmp     eax,$b
    mov     eax,1 ; true
    je      $+7  ; Jump if equals
    mov     eax,0 ; false
}/