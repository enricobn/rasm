Doing
------
- try to re enable inline
  - the problem arises with lambda space
  - now I think the problem is in function_call_parameters.resolve_asm_parameters because when we are inside another function call,
    in the emitted code of the outside function for reserving space for the parameters,
    that will be emitted after (in time), but obviously is positioned before in the code, I already know all the parameters that will be added,
    but during the method of the inner function, I don't know it.

    For example, I could have:
    outerFunction(innerFunction(a), innerFunction(b))

    given:
    outerFunction and innerFunction inline
    SP=0
    BP=0

    the pseudocode:

    reserve 2 slots for the parameters of outerFunction
    SP=-2
        reserve a slot for parameter of innerFunction
        SP=-3
            inline innerFunction
            inlining inner function I should access to BP-3, but I don't know that the outerFunction needs 2 slots, the rules
            to know if a parameter should be put in the stack are a bit complex, so the slots are accumulated on the way...

    An idea should be to refactor the code in a way that I can calculate the slots in advance...

Next
-----
- bug when a parameter of an asm function starts the same as another : v v1
  - I must process them in size order descending
- bug when an enum variant starts the same as another : T T1
- delete asm, object and executable file on compile
- write and, or, not in asm
- I think include messes up reporting error line
- error if there's a function named the same way as a lambda parameter
- put standard libraries in another path
- support for boolean
- optimize the copy of the parent lambda space: do not create parameters that are overridden by parent memcopy
- test inner lambda that get a value from a parent lambda parameter
- optimize memory for lambda space:
  - if there are more lambda in a call, all share the same lambda space (but not the address to the function), now it's duplicated:
    - I can create only one lambda space, then I can pass to the lambda, the address to the real function and the address to the lambda space
- implement range
- rename asm to native
- user cannot define native functions
- some functions from the std library should not be called (tag with internal?), for example malloc, memcopy
- optimize fibonacci
    - backend for 32 and 64 bit
    - move more code as possible from codegen to function_call_parameters
- refactor codegen lambda parameters: it's too complex
- enum:
  - match function should be enum::match, but it's not supported by parser, in general I would like to have some namespace for functions, to be xx.yy.zz::function_name
- I can close an already closed TokensGroup (make a test)
- safe command line arguments (use Option?)
- add command line argument to print the syntax tree (codegen/md.rs -> Parser::print(&self.module))
- rename lambda to closure?
- line errors in codegen
- type checker
- type parameters for functions
- move std.rasm in another folder
- split std.rasm
  - a file for not asm functions
  - io.rasm
  - string.rasm
  - enum.rasm
-