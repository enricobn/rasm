Doing
------
- fibonacci, example in Java :

    static int fib(int n) {
        if (n <= 1)
           return n;
        return fib(n-1) + fib(n-2);
    }

    asm(n: i32) -> i32[eax] /{

    }/
  - lambda functions has parameters according to the context, but example functions (if) don't pass those parameters:
    - when in codegen we call a function that has lambda as parameters, add to the stack, the count of the context variables, 
      then the values of the context variables, pay attention that you must pass the context variables
      in reverse order then the count, then the normal parameters, so when the function consumes the parameters, the parameter at 4+4 is
      the real first parameter. Example:
      if(0, { nadd(n1, n2);}, { nadd(n2, n3); }}
      we push: n3,n2,n1,3,lambda2,lambda1,0
      // the real parameters
      [ebp+4+4]=0
      [ebp+4+8]=lambda1
      [ebp+4+12]=lambda2
      // the "context" parameters
      [ebp+4+16]=3 // the count
      [ebp+4+20]=n1
      [ebp+4+24]=n2
      [ebp+4+28]=n3

      We can try to make a helper function (not an asm block, but an assembler hardcoded function) to which we pass the address in the stack for the count,
      (ebp+4+16 in the example) then if pushes all the context parameters, in reverse order:
      push: n3,n2,n1
      The function which accepts lambdas as parameters, should call the helper function before calling each lambda.
      Pay attention to the PC, I don't think we can push elements in the stack and not remove them before return,
      if we don't manage the PC

Next
-----
import a .rasm file