Doing
------

Bug
----
- consts are not reliable: if a const is defined with a function call, that uses a const that is defined after, 
  then it will compile, but it will crash at runtime!!! Add a verify or sort them by dependency
- "Universal Polymorphism" can create an infinite recursion, for example:
  we declare a function like
    add<T>(o1: str, o2: T) -> str {
        add(o1, toString(o2));
    }

  and a function like

    toString(s: str) -> str {
        s;
    }

  and we don't declare a non-generic function for add(s1: str, s2: str), calling add with two strings leads to an infinite recursion!!!
- sometimes "test_can_lambda_be_in_stack_native_type" fails in the assertion

Road to language version 1.0.0 (not compiler)
-----------------------------------------------
- array type?
  
Major
-----
- command line tool:
  - add "new" for creating a new project
  - add "init" for creating a new project in the current folder
- I don't like methods to handle "generic prefix" in AST, it should be handled outside the AST modules
- populate target for ASTFunctionDef, for regular functions (not builtin), with the name of the type of the first 
  parameter, even if generic when not completely generic (Option<T>)? Adjust code completion
- sometimes are added structs / enum / functions that are not used. It can be verified compiling with c target the test/enum.rasm
- rename EnhancedASTModule: it is the untyped container for all the modules in the project
- move all asm code to backend
- List library
- SDL library
- library from http (https)
- library from git
- Unit type: ()
- cannot ignore a return value from a function:
    // This is an invalid code
    add(10, 10);
    ...

    // This is a valid code
    println(10);
    ...
    - check for unused parameters, let and static let, it should be an error
- it would be better if we cannot use .someFunction without parenthesis, if the function does not return anything
- visibility
  - public (pub)
  - private (default)
  - readonly
    - structs
      - symbol is public
      - constructor is private
      - setters are private
  - opaque
    - structs
      - symbol is public
      - constructor is private
      - setters are private
      - getters are private
- optimize
  - can a recursive function's lambda space be reused?
- threads library
- use Result in standard library
- standardize compiler errors with source

Minor
------
- Vec
  - vecFilter and vecFoldL dereference
  - vecFilter shrink (add a shrink function that shrinks allocated memory)
- asm allocator
  - check for size >= allocated and use shrink
  - try to pack consecutive free "slots"
- TextMacro:
    - is it possible to use TextMacro in standard functions? (but for what?)
    - is it possible to inline the functions called with TextMacro?
- game of life: if we don't pass a number, it should run until no cells are alive
- type check
  - use Result
- delete asm, object and executable file before compile
- error if there's a function named the same way as a lambda parameter (or give precedence to parameter?)
- test inner lambda that get a value from a parent lambda parameter
- optimize memory for lambda space:
  - if there are more lambda in a call, all share the same lambda space (but not the address to the function), now it's duplicated:
    - I can create only one lambda space, then I can pass the address to the real function and the address to the lambda space, to the lambda,
      or a single pointer to a "structure" where the first word is the pointer to the function and the second the pointer to the lambda space
- refactor codegen lambda parameters: it's too complex
- I would like to have some namespace for functions, to be xx.yy.zz::function_name
- I can close an already closed TokensGroup (make a test)
- add command line arguments to the compiler:
  - to print the syntax tree
  - to print memory allocation
  - to debug asm
  - to run the program
- rename lambda to closure?
- more on error source in codegen

Ideas
------
- string and number literals (array?) should be specific types (strLit, intLit, decLit) that have a string representation,
  and let i64,i32,f64,f32 etc. be native types, that can be constructed with those literals, but we 
  need a way to check, at compile time, if the literal can be stored in that particular native type
- stdlib: print and prinln go to stdout, the ones with file as input must be called writeln and write
- in type check, try to evaluate in opposite order:
  fa(fb(p1, p2), fc(p3, p4)) => p1.fb(p2).fa(p3.fc(p4))
  we should evaluate the type of p1 and p2, so we have the type of fb
  then we evaluate p3 and p4, so we have the type of fc
  then we have the type of fa
