pub enum MacroStatementResult {
    MacroStatementOk(statements: Vec<ASTStatement>, functions: Vec<ASTFunctionDef>),
    MacroError(message: str)
}

pub enum MacroExpressionResult {
    MacroExpressionOk(expr: ASTExpression, functions: Vec<ASTFunctionDef>),
    MacroError(message: str)
}

pub enum MacroAttributeResult {
    MacroAttributeOk(functions: Vec<ASTFunctionDef>),
    MacroError(message: str)
}

pub struct ASTModule {
    body: Vec<ASTStatement>,
    functions: Vec<ASTFunctionDef>,
    enums: Vec<ASTEnumDef>,
    structs: Vec<ASTStructDef>,
    types: Vec<ASTTypeDef>
}

pub fn toString(module: ASTModule) -> str {
    // TODO enums
    // TODO structs
    // TODO types
    module.body.join("\n")
    .add(module.functions.join("\n"));
}

pub enum ASTStatement {
    ASTExpressionStatement(expr: ASTExpression),
    ASTLetStatement(name: str, expr: ASTExpression),
    ASTConstStatement(name: str, expr: ASTExpression, modifiers: ASTModifiers)
}

pub fn toString(stmt: ASTStatement) -> str {
    stmt.match(
        fn (expr) { toString(expr);}, 
        fn (name, expr) { "let ".add(name).append(expr); },
        fn (name, expr, modifiers) { "const ".add(name).append(expr); }
    ).add(";");
}

pub struct ASTModifiers {
    public: bool
}

pub enum ASTExpression {
    ASTFunctionCallExpression(call: ASTFunctionCall),
    ASTValueRefExpression(name: str),
    ASTValueExpression(value: ASTValue),
    ASTLambdaExpression(lambda: ASTLambdaDef)
}

pub fn toString(expr: ASTExpression) -> str {
    expr.match(
        fn(call) { call.toString();},
        fn(name) { name; },
        fn(value) { value.toString(); },
        fn(lambda) { lambda.toString(); }
    );
}

pub struct ASTFunctionCall {
    functionName: str,
    parameters: Vec<ASTExpression>,
    generics: Vec<ASTType>,
    target: Option<str>,
    macro: bool
}

pub fn toString(call: ASTFunctionCall) -> str {
    let prefix = if(call.generics.len.eq(0),{
            "";
        }, {
            "<".add(call.generics.map(fn(it) { it.toString();}).join(", ")).add(">");
        });

    let suffix = if(call.macro, "!", "");
    call.functionName.add(suffix).add(prefix).append("(")
    .append(call.parameters.join(", "))
    .append(")");
}

pub enum ASTValue {
    ASTStringValue(value: str),
    ASTBooleanValue(value: bool),
    ASTIntegerValue(value: int),
    ASTCharValue(value: str),
    ASTFloatValue(value: float)
}

pub fn toString(v: ASTValue) -> str {
    v.match(
        fn(value) { "\"".add(value).add("\""); }, 
        fn(value) { if(value, "true", "false"); },
        fn(value) { value.toString(); },
        fn(value) { value; },
        fn(value) { value.toString(); }
    );
}

pub enum ASTType {
    ASTBuiltinType(kind: ASTBuiltinTypeKind),
    ASTGenericType(
        name: str,
        types: Vec<ASTType>,
    ),
    ASTCustomType(name: str, generics: Vec<ASTType>),
    ASTUnitType
}

pub fn toString(astType: ASTType) -> str {
    astType.match(
        fn(builtin) { builtin.toString(); },
        fn(name, types) { name; },
        fn(name, generics) { name; },
        { "()"; }
    );
}

pub enum ASTBuiltinTypeKind {
    ASTBooleanType,
    ASTCharType,
    ASTIntegerType,
    ASTFloatType,
    ASTStringType,
    ASTLambdaType(
        parameters: Vec<ASTType>,
        returnType: ASTType
    )
}

pub fn toString(kind: ASTBuiltinTypeKind) -> str {
    kind.match(
        { "bool"; },
        { "char"; },
        { "int"; },
        { "float"; },
        { "str"; },
        fn(parameters, returnType) { "lambda TODO"; }
    );
}

pub struct ASTLambdaDef {
    parameterNames: Vec<str>,
    body: Vec<ASTStatement>
}

pub fn toString(def: ASTLambdaDef) -> str {
    "fn(".add(
        def.parameterNames.join(","))
    .add(") {")
        .append(def.body.join("\n"))
        .add("}")
        ;
}

pub struct ASTFunctionDef {
    name: str,
    parameters: Vec<ASTParameterDef>,
    returnType: ASTType,
    body: ASTFunctionBody,
    genericTypes: Vec<str>,
    modifiers: ASTModifiers,
    target: Option<str>
}

pub fn toString(def: ASTFunctionDef) -> str {
    let returnType = def.returnType.match(
        fn(builtin) { " -> ".append(builtin); },
        fn(name, types) { " -> ".add(name); },
        fn(name, generics) { 
            " -> ".add(name)
            .add(if(generics.len.greater(0), "<".add(generics.join(",")).add(">"), "")); 
        },
        { ""; }
    );

    let body = def.body.match(
        fn(statements) { statements.join("\n"); },
        fn(nativeBody) { nativeBody;}
    );

    let parameters = def.parameters.join(", ");
    let genericTypes = def.genericTypes.join(", ");

    if(def.modifiers.public, "pub ", "")
    .add("fn ")
    .add(def.name)
    .add(if(genericTypes.len.greater(0), "<".add(genericTypes).add(">"), ""))
    .add("(")
    .add(parameters)
    .add(") ")
    .add(returnType)
    .add(" {\n")
    .add(body)
    .add(" }\n");

}

pub struct ASTParameterDef {
    name: str,
    astType: ASTType
}

pub fn toString(def: ASTParameterDef) -> str {
    def.name.add(" : ").append(def.astType);
}

pub enum ASTFunctionBody {
    RASMBody(statements: Vec<ASTStatement>),
    NativeBody(body: str)
}

pub struct ASTEnumDef {
    name: str,
    typeParameters: Vec<str>,
    variants: Vec<ASTEnumVariantDef>,
    modifiers: ASTModifiers
}

pub struct ASTEnumVariantDef {
    name: str,
    parameters: Vec<ASTParameterDef>
}

pub struct ASTStructDef {
    name: str,
    typeParameters: Vec<str>,
    properties: Vec<ASTStructPropertyDef>,
    modifiers: ASTModifiers
}

pub struct ASTStructPropertyDef {
    name: str,
    astType: ASTType
}

pub struct ASTTypeDef {
    name: str,
    typeParameters: Vec<str>,
    body: str,
    modifiers: ASTModifiers
}