pub enum MacroResult {
    MacroModule(module: ASTModule),
    MacroError(message: str)
}

pub struct ASTModule {
    body: Vec<ASTStatement>,
    functions: Vec<ASTFunctionDef>,
    enums: Vec<ASTEnumDef>,
    structs: Vec<ASTStructDef>,
    types: Vec<ASTTypeDef>
}

pub fn toString(module: ASTModule) -> str {
    // TODO functions
    // TODO enums
    // TODO structs
    // TODO types
    module.body.join("\n");
}

pub enum ASTStatement {
    ASTExpressionStatement(expr: ASTExpression),
    ASTLetStatement(name: str, expr: ASTExpression),
    ASTConstStatement(name: str, expr: ASTExpression, modifiers: ASTModifiers)
}

pub fn toString(stmt: ASTStatement) -> str {
    stmt.match(
        fn (expr) { toString(expr);}, 
        fn (name, expr) { "let ".add(name).append(expr); },
        fn (name, expr, modifiers) { "const ".add(name).append(expr); }
    ).add(";");
}

pub struct ASTModifiers {
    public: bool
}

pub enum ASTExpression {
    ASTFunctionCallExpression(call: ASTFunctionCall),
    ASTValueRefExpression(name: str),
    ASTValueExpression(value: ASTValue),
    ASTLambdaExpression(lambda: ASTLambdaDef)
}

pub fn toString(expr: ASTExpression) -> str {
    expr.match(
        fn(call) { call.toString();},
        fn(name) { name; },
        fn(value) { value.toString(); },
        fn(lambda) { lambda.toString(); }
    );
}

pub struct ASTFunctionCall {
    functionName: str,
    parameters: Vec<ASTExpression>,
    generics: Vec<ASTType>,
    target: Option<str>
}

pub fn toString(call: ASTFunctionCall) -> str {
    call.functionName.append("(")
    .append(call.parameters.join(", "))
    .append(")");
}

pub enum ASTValue {
    ASTStringValue(value: str),
    ASTBooleanValue(value: bool),
    ASTIntegerValue(value: int),
    ASTCharValue(value: str),
    ASTFloatValue(value: float)
}

pub fn toString(v: ASTValue) -> str {
    v.match(
        fn(value) { "\"".add(value).add("\""); }, 
        fn(value) { if(value, "true", "false"); },
        fn(value) { value.toString(); },
        fn(value) { value; },
        fn(value) { value.toString(); }
    );
}

pub enum ASTType {
    ASTBuiltinType(kind: ASTBuiltinTypeKind),
    ASTGenericType(
        name: str,
        types: Vec<ASTType>,
    ),
    ASTCustomType(name: str, generics: Vec<ASTType>),
    ASTUnitType
}

pub enum ASTBuiltinTypeKind {
    ASTBooleanType,
    ASTCharType,
    ASTIntegerType,
    ASTFloatType,
    ASTStringType,
    ASTLambdaType(
        parameters: Vec<ASTType>,
        returnType: ASTType
    )
}

pub struct ASTLambdaDef {
    parameterNames: Vec<str>,
    body: Vec<ASTStatement>
}

pub fn toString(def: ASTLambdaDef) -> str {
    "fn(".add(
        def.parameterNames.join(","))
    .add(") {")
        .append(def.body.join("\n"))
        .add("}")
        ;
}

pub struct ASTFunctionDef {
    name: str,
    parameters: Vec<ASTParameterDef>,
    returnType: ASTType,
    body: ASTFunctionBody,
    genericTypes: Vec<str>,
    modifiers: ASTModifiers,
    target: Option<str>
}

pub struct ASTParameterDef {
    name: str,
    astType: ASTType
}

pub fn toString(def: ASTParameterDef) -> str {
    def.name.add(" : TODO"); // TODO .append(def.astType);
}

pub enum ASTFunctionBody {
    RASMBody(statements: Vec<ASTStatement>),
    NativeBody(body: str)
}

pub struct ASTEnumDef {
    name: str,
    typeParameters: Vec<str>,
    variants: Vec<ASTEnumVariantDef>,
    modifiers: ASTModifiers
}

pub struct ASTEnumVariantDef {
    name: str,
    parameters: Vec<ASTParameterDef>
}

pub struct ASTStructDef {
    name: str,
    typeParameters: Vec<str>,
    properties: Vec<ASTStructPropertyDef>,
    modifiers: ASTModifiers
}

pub struct ASTStructPropertyDef {
    name: str,
    astType: ASTType
}

pub struct ASTTypeDef {
    name: str,
    typeParameters: Vec<str>,
    body: str,
    modifiers: ASTModifiers
}