/* struct RasmPointer_ {
        void *address;
        int count;
        struct RCList* zero;
   };
*/

pub type RasmPointer(false, "struct RasmPointer_ *");

pub native exitMain(status: i32) /{
    exit($status);
}/

pub native argc() -> i32 /{
    return argc_;
}/

pub native argv(i: i32) -> Option<str> /{
    if (i >= argc_) {
        struct RasmPointer_ *result__ = rasmMalloc(sizeof(struct Enum));
        struct Enum *result_ = (struct Enum *)result__->address;
        $enumVariantDeclaration(v_, None)
        result_->variant_num = 1;
        result_->variant = v__;
        return result__;
    } else {
        return
        $call(Option::Some, argv_[$i]:str)
        ;
    }

}/

pub native deref(address: RasmPointer) /{
    $include(<stdlib.h>)

    #ifdef __RASM_DEBUG__
    if (address == NULL) {
        printf("NULL address\n");
        return;
    }

    printf("deref(%p)", address->address);
    #endif

    int count = --address->count;
    #ifdef __RASM_DEBUG__
        printf(" count %d\n", count);
    #endif

    if (count == 0) {
        push_zero(address);
    }

    // printf("Cannot find reference!!\n");
    // $call(exitMain, 1)
    return;

}/

pub native addRef(address: RasmPointer) /{
    $include(<stdlib.h>)

    #ifdef __RASM_DEBUG__
    if (address == NULL) {
        printf("NULL address\n");
        return;
    }

    printf("addRef(%p)", address->address);
    #endif

    int count = ++address->count;

    if (count == 1) {
        if (address->zero != NULL) {
            remove_from_zero_list(address->zero);
            address->zero = NULL;
        }
    }
}/

pub native freeReferences() /{
    free_zero();
}/