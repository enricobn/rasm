pub type RasmPointer(false, "void *");

pub native exitMain(status: i32) /{
    exit($status);
}/

pub native argc() -> i32 /{
    return argc_;
}/

pub native argv(i: i32) -> Option<str> /{
    if (i >= argc_) {
        $enumDeclaration(result_)
        $enumVariantDeclaration(v_, None)
        result_->variant_num = 1;
        result_->variant = v_;
        return result_;
    } else {
        return
        $call(Option::Some, argv_[$i]:str)
        ;
    }

}/

/* struct RasmReference {
        void *address;
        int count;
   }
*/

pub native deref(address: RasmPointer) /{
    $include(<stdlib.h>)
    // return;
    // printf("deref %p\n", address);
    for (int i = 0; i < RASM_REFERENCES_COUNT; i++) {
        if (RASM_REFERENCES[i] != NULL && RASM_REFERENCES[i]->address == address) {
            //printf("found with count %d\n", RASM_REFERENCES[i]->count);
            if (RASM_REFERENCES[i]->count < 0) {
                printf("count < 0");
            }

            if (--RASM_REFERENCES[i]->count == 0) {
                /*
                printf("freeing %p\n", address);
                free(RASM_REFERENCES[i]->address);
                free(RASM_REFERENCES[i]);
                RASM_REFERENCES[i] = NULL;
                printf("freed %p\n", address);
                */
            }
            return;
        }
    }
    // printf("Cannot find reference!!\n");
    // $call(exitMain, 1)
    return;

}/

pub native addRef(address: RasmPointer) /{
    $include(<stdlib.h>)

    // return;
    // printf("addRef %p\n", address);
    int firstFree = -1;

    for (int i = 0; i < RASM_REFERENCES_COUNT; i++) {
        
        if (RASM_REFERENCES[i] != NULL && RASM_REFERENCES[i]->address == address) {
            RASM_REFERENCES[i]->count++;
            // printf("addRef count = %d\n", RASM_REFERENCES[i]->count);
            return;
        } else if (RASM_REFERENCES[i] == NULL || RASM_REFERENCES[i]->count == 0) {
            if (firstFree == -1) {
                firstFree = i;
            }
        }
    }

    if (firstFree == -1) {
        // printf("Out of memory for references!!\n");
        // $call(exitMain, 1)
        return;
    }

    if (RASM_REFERENCES[firstFree] != NULL  && RASM_REFERENCES[firstFree]->count == 0) {
        free(RASM_REFERENCES[firstFree]->address);
        free(RASM_REFERENCES[firstFree]);
    }

    struct RasmReference *rasmReference = malloc(sizeof(struct RasmReference));
    rasmReference->address = address;
    rasmReference->count = 1;
    RASM_REFERENCES[firstFree] = rasmReference;
    // printf("addRef count = 1\n");
}/


pub native initRasmReferences() /{
    for (int i = 0; i < RASM_REFERENCES_COUNT; i++) {
        RASM_REFERENCES[i] = NULL;
    }
}/