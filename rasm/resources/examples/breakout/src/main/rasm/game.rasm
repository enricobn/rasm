pub struct GameState {
    stage: GameStage,
    world: World,
    fps: FPS
}

pub struct World {
    bricks: Vec<Brick>,
    ball: Ball,
    bar: Bar,
    score: int,
    lives: int,
}

enum GameStage {
    RunBall(time: TimeVal),
    Run
}

// 2 sec.
const RESTARTTIME = 2000000;

pub fn initialGameState() -> GameState {
    GameState(Run(), initialWorld(), FPS(0, now(), 0));
}

fn initialWorld() -> World {
    let bricks = cartesianProduct(vecRange(0, 30), vecRange(0, 10), 
        fn(x, y) {
            let yellow = random(10).eq(0);

            let color = if(yellow, COLORS.yellow, COLORS.red);
            let score = if(yellow, 100, 10);
            Brick(mul(x, BRICKWIDTH), add(HEADERHEIGHT, mul(y, BRICKHEIGHT)) , color, score); 
        });

    let now = now();

    World(bricks, initialBall(now), initialBar(now), 0, 3);
}

fn initialBar(now: TimeVal) -> Bar {
    Bar(500.0, 0.0, now);
}

pub fn update(keys: Vec<int>, gameState: GameState) -> GameResult {
    let stage = gameState.stage;
    let fps = gameState.fps.update();

    let actualTime = now();

    let newGameState = stage.match(
        fn(time) {
            if(actualTime.elapsedTime(time).greater(RESTARTTIME), {
                // we must "reset" the ball lastUpdate, because the movement of the ball depends on it
                gameState.update(world, ball, fn(ball) { ball.lastUpdate(actualTime);})
                    .stage(Run())
                    .fps(fps);
            }, {
                // we want the player to move
                gameState.update(world, bar, fn(bar) { bar.update(actualTime, keys);})
                .fps(fps);
            });
        }, 
        {
            let newWorld = update(gameState.world, keys);

            if(newWorld.ball.y.greater(HEIGHT), {
                let lives = newWorld.lives.sub(1);
                GameState(
                    RunBall(actualTime), 
                    gameState.world
                        .ball(initialBall(actualTime))
                        .bar(initialBar(actualTime))
                        .lives(lives),
                    fps
                );
            }, {
                GameState(stage, newWorld, fps);
            });
        }
    );

    let lives = newGameState.world.lives;
    let score = newGameState.world.score;

    if(lives.eq(0), { End(score);}, { Play(newGameState);});
}

fn update(world: World, keys: Vec<int>) -> World {
    // sleep(0, 1500);
    let actualTime = now();
    let lives = world.lives;
    let ball = world.ball;
    let bricks = world.bricks;
    
    let newBar = world.bar.update(actualTime, keys);
    let newBall = ball.update(actualTime);

    let ballGone = ball.y.add(BALLSIZE).greater(BARY);

    if(ballGone, {
        World(bricks, newBall, newBar, world.score, lives);
    }, {
        let collision = bricks.collision(newBall);
        let newScore = collision.match(fn(b) { world.score.add(b.value);}, { world.score;});
        let newBricks = collision.match(fn(b) { bricks.filter(neq.curry(b)); }, { bricks; });

        if(newBall.collides(newBar.x), {
            let ballAfterCollision = Ball(ball.x, ball.y, ball.xDir, ball.yDir.flip(), actualTime);
            let newBall2 = ballAfterCollision.update(actualTime);
            World(newBricks, newBall2, newBar, newScore, lives);
        }, {
            collision.match(fn(brick) {
                let ballAfterCollision = ball.afterCollision(brick).lastUpdate(actualTime);
                World(newBricks, ballAfterCollision, newBar, newScore, lives);
            },
            {
                World(newBricks, newBall, newBar, newScore, lives);
            });
        });

    });
}

fn collision(bricks: Vec<Brick>, ball: Ball) -> Option<Brick> {
    bricks.filter(collides.curry(ball)).first;
}

pub fn render(ren: SDLRenderer, resources: Resources, gameState : GameState) {
    gameState.stage.match(
        fn(time) {
            render(ren, resources, gameState.world, gameState.fps.fps);
            let restart = RESTARTTIME.sub(now().elapsedTime(time)).divf(1000000);
            centerAndRelease(ren, resources.font, "Start in ".append(restart.toInt(0).add(1)), HEIGHT.div(2), 
                COLORS.green);
        }, 
        { render(ren, resources, gameState.world, gameState.fps.fps); }
    );
}

// TODO put this in the SDL library, but it depends on WIDTH (it can be passed as an argument),
// and on the size of the Font, which is for now not exposed
fn centerAndRelease(ren: SDLRenderer, font: SDLFont, text: str, y: int, color: SDLColor) {
    let sText = sdlCreateText(ren, font, text, color);
    sdlRenderAndRelease(ren, sText, WIDTH.sub(text.len.mul(12)).div(2), y);
}

fn render(ren: SDLRenderer, resources: Resources, world: World, fps: int) {
    let font = resources.font;

    world.bricks.forEach(fn(brick) {
        sdlSetRenderDrawColor(ren, brick.color);
        sdlRenderFillRect(ren, SDLRect(brick.x.add(1), brick.y.add(1), BRICKWIDTH.sub(2), BRICKHEIGHT.sub(2)));
    });

    sdlSetRenderDrawColor(ren, COLORS.white);

    sdlRenderFillRect(ren, SDLRect(world.bar.x.toInt(0), BARY, BARWIDTH, BARHEIGHT));

    sdlRenderFillRect(ren, SDLRect(world.ball.x.toInt(0), world.ball.y.toInt(0), BALLSIZE, BALLSIZE));

    sdlSetRenderDrawColor(ren, COLORS.blue);
    sdlRenderFillRect(ren, SDLRect(0, 0, WIDTH, HEADERHEIGHT));

    let scoreText = sdlCreateText(ren, font, "Score: ".append(world.score), COLORS.green);
    sdlRenderAndRelease(ren, scoreText, 2, 2);

    let livesText = sdlCreateText(ren, font, "Lives: ".append(world.lives), COLORS.green);
    sdlRenderAndRelease(ren, livesText, 200, 2);

    let fpsText = sdlCreateText(ren, font, "FPS: ".append(fps), COLORS.green);
    sdlRenderAndRelease(ren, fpsText, 400, 2);
}