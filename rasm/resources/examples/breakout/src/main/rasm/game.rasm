pub struct GameState {
    stage: GameStage,
    world: World,
    fps: FPS
}

pub struct World {
    bricks: Vec<Brick>,
    ball: Ball,
    bar: Bar,
    score: int,
    lives: int,
    ballGone: bool
}

enum GameStage {
    RunBall(time: TimeVal),
    Run
}

// 3 sec.
const RESTARTTIME = 3000000;

pub fn initialGameState() -> GameState {
    GameState(Run(), initialWorld(), FPS(0, now(), 0));
}

fn initialWorld() -> World {
    let bricks = cartesianProduct(vecRange(0, 30), vecRange(0, 10), 
        fn(x, y) { Brick(mul(x, BRICKWIDTH), add(HEADERHEIGHT, mul(y, BRICKHEIGHT)) , COLORS.red); });

    let now = now();

    World(bricks, initialBall(now), initialBar(now), 0, 3, false);
}

fn initialBar(now: TimeVal) -> Bar {
    Bar(500.0, 0.0, now);
}

pub fn update(keys: Vec<int>, gameState: GameState) -> GameResult {
    let stage = gameState.stage;
    let fps = gameState.fps.update();

    let actualTime = now();

    let newGameState = stage.match(
        fn(time) {
            if(actualTime.elapsedTime(time).greater(RESTARTTIME), {
                gameState
                    // we must update the ball lastUpdate, because the movement of the ball depends on it
                    .world(fn(w) { w.ball(fn(b) { b.lastUpdate(actualTime);});})
                    .stage(Run())
                    .fps(fps);
            }, {
                gameState
                // we want the player to move
                .world(fn(w) { w.bar(fn(b) { b.update(actualTime, keys);});})
                .fps(fps);
            });
        }, 
        {
            let newWorld = update(gameState.world, keys);

            if(newWorld.ball.y.greater(HEIGHT), {
                let lives = newWorld.lives.sub(1);
                GameState(
                    RunBall(actualTime), 
                    gameState.world
                        .ball(initialBall(actualTime))
                        .bar(initialBar(actualTime))
                        .lives(lives)
                        .ballGone(false),
                    fps
                );
            }, {
                GameState(stage, newWorld, fps);
            });
        }
    );

    let lives = newGameState.world.lives;
    let score = newGameState.world.score;

    if(lives.eq(0), { End(score);}, { Play(newGameState);});
}

fn update(world: World, keys: Vec<int>) -> World {
    // sleep(0, 1500);
    let actualTime = now();
    let lives = world.lives;
    let ball = world.ball;
    let bricks = world.bricks;
    let ballGone = world.ballGone;

    let newBar = world.bar.update(actualTime, keys);
    let newBall = ball.update(actualTime);
    if(ballGone, {
        World(bricks, newBall, newBar, world.score, lives, true);
    }, {
        let collision = bricks.collision(newBall);
        let newScore = collision.match(fn(b) { world.score.add(10);}, { world.score;});
        let newBricks = collision.match(fn(b) { bricks.filter(neq.curry(b)); }, { bricks; });

        if(newBall.collides(newBar.x), {
            let ballAfterCollision = Ball(ball.x, ball.y, ball.xDir, ball.yDir.flip(), actualTime);
            let newBall2 = ballAfterCollision.update(actualTime);
            World(newBricks, newBall2, newBar, newScore, lives, false);
        }, {
            collision.match(fn(brick) {
                let ballAfterCollision = ball.afterCollision(brick).lastUpdate(actualTime);
                World(newBricks, ballAfterCollision, newBar, newScore, lives, false);
            },
            {
                if(ball.y.add(BALLSIZE).greater(BARY), {
                    World(newBricks, newBall, newBar, newScore, lives, true);
                }, {
                    World(newBricks, newBall, newBar, newScore, lives, false);
                });
            });
        });

    });
}

fn collision(bricks: Vec<Brick>, ball: Ball) -> Option<Brick> {
    bricks.filter(collides.curry(ball)).first;
}

pub fn render(ren: SDLRenderer, resources: Resources, gameState : GameState) {
    gameState.stage.match(
        fn(time) {
            render(ren, resources, gameState.world, gameState.fps.fps);
            let restart = RESTARTTIME.sub(now().elapsedTime(time)).divf(1000000);
            centerAndRelease(ren, resources.font, "Start in ".append(restart.toInt(0).add(1)), HEIGHT.div(2), 
                COLORS.green);
        }, 
        { render(ren, resources, gameState.world, gameState.fps.fps); }
    );
}

// TODO put this in the SDL library, but it depends on WIDTH (it can be passed as an argument),
// and on the size of the Font, which is for now not exposed
fn centerAndRelease(ren: SDLRenderer, font: SDLFont, text: str, y: int, color: SDLColor) {
    let sText = createSDLText(ren, font, text, color);
    renderAndRelease(ren, sText, SDLRect(WIDTH.sub(text.len.mul(12)).div(2), y, text.len.mul(12), 24));
}

fn render(ren: SDLRenderer, resources: Resources, world: World, fps: int) {
    let font = resources.font;

    world.bricks.forEach(fn(brick) {
        sdlSetRenderDrawColor(ren, brick.color);
        sdlRenderFillRect(ren, SDLRect(brick.x.add(1), brick.y.add(1), BRICKWIDTH.sub(2), BRICKHEIGHT.sub(2)));
    });

    sdlSetRenderDrawColor(ren, COLORS.white);

    sdlRenderFillRect(ren, SDLRect(world.bar.x.toInt(0), BARY, BARWIDTH, BARHEIGHT));

    sdlRenderFillRect(ren, SDLRect(world.ball.x.toInt(0), world.ball.y.toInt(0), BALLSIZE, BALLSIZE));

    sdlSetRenderDrawColor(ren, COLORS.blue);
    sdlRenderFillRect(ren, SDLRect(0, 0, WIDTH, HEADERHEIGHT));

    let scoreText = createSDLText(ren, font, "Score: ".append(world.score), COLORS.green);
    renderAndRelease(ren, scoreText, SDLRect(2, 2, 100, 24));

    let livesText = createSDLText(ren, font, "Lives: ".append(world.lives), COLORS.green);
    renderAndRelease(ren, livesText, SDLRect(200, 2, 100, 24));

    let fpsText = createSDLText(ren, font, "FPS: ".append(fps), COLORS.green);
    renderAndRelease(ren, fpsText, SDLRect(400, 2, 100, 24));
}