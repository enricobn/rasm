pub enum GameResult {
    Play(state: GameState),
    End(score: int)
}

pub struct Resources {
    font: SDLFont
}

pub struct HighScore {
    score: int,
    time: TimeVal
}

struct State {
    resources: Resources,
    keys: Vec<int>,
    stage: Stage,
    highScores: Vec<HighScore>
}

pub enum Stage {
    Menu(menuState: MenuState),
    Game(gameState: GameState)
}

pub struct Colors {
    black: SDLColor,
    blue: SDLColor,
    green: SDLColor,
    red: SDLColor,
    yellow: SDLColor,
    white: SDLColor
}

pub fn Colors() -> Colors {
    Colors(
        SDLColor(0, 0, 0, 255),
        SDLColor(0, 0, 255, 255),
        SDLColor(0, 255, 0, 255),
        SDLColor(255, 0, 0, 255),
        SDLColor(255, 255, 0, 255),
        SDLColor(255, 255, 255, 255)
    );
}

enum Message {
    KeyMessage(event: KeyEvent),
    Tick
}

pub const WIDTH = 1024;
pub const HEIGHT = 768;
pub const BRICKWIDTH = 34;
pub const BRICKHEIGHT = 10;
pub const BARWIDTH = 80;
pub const BARHEIGHT = 10;
pub const BARY = HEIGHT.sub(BARHEIGHT);
pub const HEADERHEIGHT = 30;
pub const BALLSIZE = 5;
pub const COLORS = Colors();

let sdl = sdlInit();
let ttf = sdl.sdlTTFInit();

let font = ttf.sdlOpenFont(resource("DejaVuSerif.ttf"), 24);

let highScores = loadHighScores();

let initialState = State(Resources(font), Vec(), Menu(MenuState(highScores)), highScores);

let win = sdl.sdlCreateWindow("Breakout", 100, 100, WIDTH, HEIGHT);
let ren = win.sdlCreateRenderer();

run(ren, initialState, update, render, subscriptions);

ren.sdlDestroyRenderer();
win.sdlDestroyWindow();

// TODO keys are not as expected, space is 44 but should be 32!
fn update(message: Message, state: State) -> State {
    let resources = state.resources;
    let keys = state.keys;
    let stage = state.stage;
    let highScores = state.highScores;

    let newKeys = message.match(fn(e) {
          if(eq(e.key, 41), { sdlQuit(); exitMain(0);}, { }); // 41 -> ESC

          let key = e.key;
          let keyState = e.state;

          keyState.match({
            vecOf(key);
          }, {
            keys.filter(neq.curry(key));
          });
      }, { keys; });

    match(stage, 
        fn(menuState) {
            let newStage = update(resources, newKeys, menuState);
            State(resources, newKeys, newStage, highScores);
        }, 
        fn(gameState) {
            let gameResult = update(newKeys, gameState);
            gameResult.match(
                fn(newGameState) { State(resources, newKeys, Game(newGameState), highScores);}, 
                fn(score) {
                    let newHighScores = highScores.add(score);
                    writeHighScores(newHighScores);
                    State(resources, newKeys, Menu(MenuState(newHighScores)), newHighScores);
                }
            );
        }
    );
}

fn add(highScores: Vec<HighScore>, score: int) -> Vec<HighScore> {
    highScores.push(HighScore(score, now()));
}

fn render(ren: SDLRenderer, state: State) {
    sdlSetRenderDrawColor(ren, COLORS.black);
    sdlRenderClear(ren);

    let resources = state.resources;
    let stage = state.stage;

    stage.match(
        fn(menuState) { render(ren, resources, menuState);}, 
        fn(gameState) { render(ren, resources, gameState);}
    );

    sdlRenderPresent(ren);
}

fn subscriptions() -> Vec<Message> {
    let event = keyEvent();

    event.match(fn(e) {
        vecOf(KeyMessage(e));
    }, { vecOf(Tick()); });
}

fn loadHighScores() -> Vec<HighScore> {
    if(fileExists("scores.txt"), {
        let scores = readFile("scores.txt");
        let lines = scores.lines;
        lines.fmap(fn(line) {
            let splitted = line.splitToList(',');
            splitted.map3(fn(score, sec, nano) {
                score.toInt.fmap(fn(sc) {
                    sec.toInt.fmap(fn(s) {
                        nano.toInt.map(fn(n) {
                            HighScore(sc, TimeVal(s, n));
                        });
                    });
                });
            }).flatten.toList;
        }).toVec;
    }, Vec);
}

fn printHighScores(highScores: Vec<HighScore>) {
    forEach(highScores, fn(highScore) {
        print("high score ", highScore.score);
        print(", ");
        println(highScore.time);
    });
}

fn writeHighScores(highScores: Vec<HighScore>) {
    let file = createFile("scores.txt");

    forEach(highScores, fn(it) {
        print(file, it.score)
        .orElse({print(file, ",");})
        .orElse({print(file, it.time.sec);})
        .orElse({print(file, ",");})
        .orElse({println(file, it.time.nano);})
        .forEach(fn(error) {
            println(error);
            exitMain(1);
        });
    });

    close(file);
}