struct Ball {
    x: f32,
    y: f32,
    xDir: XDirection,
    yDir: YDirection,
    lastUpdate: TimeVal
}

fn initialBall(now: TimeVal) -> Ball {
    Ball(500.0, 200.0, XDirection::Right(), YDirection::Down(), now);
}

fn update(ball: Ball, actualTime: TimeVal) -> Ball {
    let x = ball.x;
    let y = ball.y;
    let xDir = ball.xDir;
    let yDir = ball.yDir;

    let lastUpdate = ball.lastUpdate;
    let elapsed = elapsedTime(actualTime, lastUpdate);

    let diff = divf(elapsed, 3000);

    let updatedX = update(x, xDir, diff);
    let newX = updatedX.first;
    let newXDir = updatedX.second;

    let updatedY = update(y, yDir, diff);
    let newY = updatedY.first;
    let newYDir = updatedY.second;

    Ball(newX, newY, newXDir, newYDir, actualTime);
}

fn update(x: f32, xDir: XDirection, diff: f32) -> Pair<f32,XDirection> {
    let newX = x.move(xDir, diff);
    let rightMargin = sub(WIDTH, BALLSIZE);

    if (greater(newX, rightMargin),
        { -> Pair(rightMargin.sub(newX.sub(rightMargin)), flip(xDir)); },
        less(newX, 0),
        { -> Pair(sub(0.0, newX), flip(xDir)); },
        { -> Pair(newX, xDir);}
    );
}

fn update(y: f32, yDir: YDirection, diff: f32) -> Pair<f32,YDirection> {
    let newY = y.move(yDir, diff);
    if(less(newY, HEADERHEIGHT),
        { -> Pair(tof32(HEADERHEIGHT).add(tof32(HEADERHEIGHT).sub(newY)), flip(yDir));},
        { -> Pair(newY, yDir);}
    );
}

fn collides(ball: Ball, brick: Brick) -> bool {
    let x = ball.x;
    let y = ball.y;

    let bx = brick.x;
    let by = brick.y;

    let xColl = x.add(BALLSIZE).greater(bx).and(x.less(bx.add(BRICKWIDTH)));
    let yColl = y.add(BALLSIZE).greater(by).and(y.less(by.add(BRICKHEIGHT)));

    xColl.and(yColl);
}

fn collides(ball: Ball, barPos: f32) -> bool {
    let x = ball.x;
    let y = ball.y;
    let bx = barPos;
    let by = HEIGHT.sub(BARHEIGHT);

    let xColl = x.add(BALLSIZE).greater(bx).and(x.less(bx.add(BARWIDTH)));
    let yColl = y.add(BALLSIZE).greater(by);

    xColl.and(yColl);
}

fn ballAfterCollision(ball: Ball, brick: Brick) -> Ball {
    let ballX = ball.x;
    let ballY = ball.y;
    let xDir = ball.xDir;
    let yDir = ball.yDir;
    let lastUpdate = ball.lastUpdate;

    let brickX = brick.x;
    let brickY = brick.y;

    let xDiff1 = ballX.sub(brickX);
    let xDiff2 = brickX.add(BRICKWIDTH).sub(ballX);
    let yDiff1 = ballY.sub(brickY);
    let yDiff2 = brickY.add(BRICKHEIGHT).sub(ballY);

    let xDiff = min(xDiff1, xDiff2);
    let yDiff = min(yDiff1, yDiff2);

    if(xDiff.less(yDiff), { -> ball.xDir(xDir.flip);}, { -> ball.yDir(yDir.flip);});
}