pub struct SDLRect {
    x: int,
    y: int,
    width: int,
    height: int
}

pub struct SDLColor {
    r: int,
    g: int,
    b: int,
    a: int
}

/* if the value is 0, which is considered an error in SDL, the program exits printing the SDL error,
otherwise returns the value */
pub fn sdlErrorIfNull<T>(value: T, message: str) -> T {
    if(isSDLNull(value), { sdlFailure(message); value; }, { value; });
}

// Events

pub enum KeyState {
    Down,
    Up
}

pub fn print(state: KeyState) {
    match(state, { print("Down");}, { print("Up");});
}

pub struct KeyEvent {
    key: int,
    state: KeyState
}

pub fn print(event: KeyEvent) {
    let key = key(event);
    let key = key(event);
    let state = state(event);
    print("key=");
    print(key);
    print(" state=");
    print(state);
}

// LOOP
fn sdlSingleLoop<CTX,MODEL>(ctx: CTX, model: MODEL, updateFun: fn(Option<KeyEvent>, MODEL) -> MODEL, renderFun: fn(CTX, MODEL) -> ()) -> MODEL {
    // println("State in sdlSingleLoop");
    // printRef(world);
    let event = keyEvent();

    match(event, fn(keyEvent) {
        let key = key(keyEvent);
        if(eq(key, 41), { exitMain(0);}, { }); // 41 -> ESC
    }, { });

    let newModel = updateFun(event, model);
    renderFun(ctx, newModel);

    newModel;
}

pub struct SDLText {
    surface: SDLSurface,
    texture: SDLTexture
}

pub fn sdlCreateText(ren: SDLRenderer, font: SDLFont, text: str, color: SDLColor) -> SDLText {
    let surface = sdlRenderTextSolid(font, text, color);
    let texture = sdlCreateTextureFromSurface(ren, surface);

    SDLText(surface, texture);
}

pub fn sdlRenderAndRelease(ren: SDLRenderer, text: SDLText, x: int, y: int) {
    sdlRender(ren, text, x, y);
    sdlDestroyTexture(text.texture);
    sdlFreeSurface(text.surface);
}

pub fn release(text: SDLText) {
    release(text.texture);
    release(text.surface);
}

pub fn release(texture: SDLTexture) {
    sdlDestroyTexture(texture);
}

pub fn release(surface: SDLSurface) {
    sdlFreeSurface(surface);
}