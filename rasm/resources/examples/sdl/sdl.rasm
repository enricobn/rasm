requires "libc"
requires "SDL2"
requires "SDL2_ttf"

extern "printf"

extern "SDL_CreateRenderer"
extern "SDL_CreateTextureFromSurface"
extern "SDL_CreateWindow"
extern "SDL_Delay"
extern "SDL_DestroyRenderer"
extern "SDL_DestroyTexture"
extern "SDL_DestroyWindow"
extern "SDL_FreeSurface"
extern "SDL_GetError"
extern "SDL_LoadBMP_RW"
extern "SDL_Init"
extern "SDL_PollEvent"
extern "SDL_RenderClear"
extern "SDL_RenderCopy"
extern "SDL_RenderFillRect"
extern "SDL_RenderPresent"
extern "SDL_RWFromFile"
extern "SDL_SetRenderDrawColor"
extern "SDL_Quit"
extern "TTF_Init"
extern "TTF_OpenFont"
extern "TTF_RenderText_Solid"

struct SDLRect {
    x: i32,
    y: i32,
    width: i32,
    height: i32
}

struct SDLColor {
    r: i32,
    g: i32,
    b: i32,
    a: i32
}

type SDLRenderer(false);
type SDLWindow(false);
type SDLSurface(false);
type SDLTexture(false);
type SDLFont(false);

/* if the value is 0, which is considered an error in SDL, the program exits printing the SDL error,
otherwise returns the value */
fn sdlErrorIfNull<T>(value: T, message: str) -> T {
    if(isSDLNull(value), { -> sdlFailure(message); value; }, { -> value; });
}

asm isSDLNull<T>(value: T) -> bool /{
    mov dword   eax, $value
    cmp     eax,0
    je .null
    mov dword eax, 0
    jmp .end
.null:
    mov dword eax, 1
.end:
}/

asm sdlFailure(message: str) /{
    $ccall(SDL_GetError)
    $ccall(printf, $message, eax)
    $ccall(SDL_Quit)
    $ccall(exit, 1)
}/

asm sdlInit() /{
    ; SDL_Init(SDL_INIT_EVERYTHING)
    $ccall(SDL_Init, 62001)
}/

asm sdlCreateWindow(title: str, x: i32, y: i32, width: i32, height: i32) -> SDLWindow /{
    $ccall(SDL_CreateWindow, $title, $x, $y, $width, $height, 4)
}/

asm sdlDelay(millis: i32) /{
    $ccall(SDL_Delay, $millis)
}/

asm sdlCreateRenderer(win: SDLWindow) -> SDLRenderer /{
    ; SDL_RENDERER_ACCELERATED = 0x00000002
    ; SDL_RENDERER_PRESENTVSYNC = 0x00000004
    $ccall(SDL_CreateRenderer, $win, -1, 6)
}/

asm sdlLoadBMP(file: str) -> SDLSurface /{
    $ccall(SDL_RWFromFile, $file, "rb")
    $ccall(SDL_LoadBMP_RW, eax, 1)
}/

asm sdlCreateTextureFromSurface(ren: SDLRenderer, surface: SDLSurface) -> SDLTexture /{
    $ccall(SDL_CreateTextureFromSurface, $ren, $surface)
}/

asm sdlFreeSurface(surface: SDLSurface) /{
    $ccall(SDL_FreeSurface, $surface)
}/

asm sdlRenderClear(ren: SDLRenderer) /{
    $ccall(SDL_RenderClear, $ren)
}/

asm sdlRenderCopy(ren: SDLRenderer, tex: SDLTexture) /{
    $ccall(SDL_RenderCopy, $ren, $tex, 0, 0)
}/

asm sdlRenderPresent(ren: SDLRenderer) /{
    $ccall(SDL_RenderPresent, $ren)
}/

asm sdlDestroyRenderer(ren: SDLRenderer) /{
    $ccall(SDL_DestroyRenderer, $ren)
}/

asm sdlDestroyTexture(tex: SDLTexture) /{
    $ccall(SDL_DestroyTexture, $tex)
}/

asm sdlDestroyWindow(win: SDLWindow) /{
    $ccall(SDL_DestroyWindow, $win)
}/

asm sdlGetError() -> str /{
    $ccall(SDL_GetError)
    ; TODO I don't know if it works or if it is correct: it is not a static string
    $call(addStaticStringToHeap, eax)
}/

asm sdlQuit() /{
    $ccall(SDL_Quit)
}/

fn sdlSetRenderDrawColor(ren: SDLRenderer, color: SDLColor) {
    sdlSetRenderDrawColor(ren, r(color), g(color), b(color), a(color));
}

asm sdlSetRenderDrawColor(ren: SDLRenderer, r: i32, g: i32, b: i32, a: i32) /{
    $ccall(SDL_SetRenderDrawColor, $ren, $r, $g, $b, $a)
}/

asm sdlRenderFillRect(ren: SDLRenderer, rect: SDLRect) /{
    $ccall(SDL_RenderFillRect, $ren, $rect)
}/

// Events

enum KeyState {
    Down,
    Up
}

fn print(state: KeyState) {
    run(state, { -> print("Down");}, { -> print("Up");});
}

struct KeyEvent {
    key: i32,
    state: KeyState
}

fn print(event: KeyEvent) {
    let key = KeyEvent::key(event);
    let state = KeyEvent::state(event);
    print("key=");
    print(key);
    print(" state=");
    print(state);
}

/*
SDL C types:

typedef union{
  Uint8 type;
  SDL_ActiveEvent active;
  SDL_KeyboardEvent key;
  SDL_MouseMotionEvent motion;
  SDL_MouseButtonEvent button;
  SDL_JoyAxisEvent jaxis;
  SDL_JoyBallEvent jball;
  SDL_JoyHatEvent jhat;
  SDL_JoyButtonEvent jbutton;
  SDL_ResizeEvent resize;
  SDL_ExposeEvent expose;
  SDL_QuitEvent quit;
  SDL_UserEvent user;
  SDL_SysWMEvent syswm;
} SDL_Event;

typedef struct{
  Uint8 type;
  Uint8 state;
  SDL_keysym keysym;
} SDL_KeyboardEvent;

typedef struct{
  Uint8 scancode;
  SDLKey sym;
  SDLMod mod;
  Uint16 unicode;
} SDL_keysym;

*/
asm keyEvent() -> Option<KeyEvent> /{
    push    ebx

    $call(malloc, 56, " for temp mem for sdl keyEvent")
    $call(addRef, eax, "temp mem for sdl keyEvent")
    push    eax

    mov     dword  ebx, [eax]
    $ccall(SDL_PollEvent, [eax]);
    cmp     eax, 0
    je      .noKey
    mov     dword eax,[ebx] ; here we have the event type
    cmp     eax, 768        ; keyDown
    jne     .noKeyDown
    $call(KeyEvent, [ebx + 16], [_enum_KeyState_Down]: KeyState)
    $addRef(eax:KeyEvent)
    push    eax
    $call(Option::Some, eax: KeyEvent)
    pop     ebx
    $deref(ebx:KeyEvent)
    jmp     .end
.noKeyDown:
    cmp     eax, 769        ; keyUp
    jne     .noKey
    $call(KeyEvent, [ebx + 16], [_enum_KeyState_Up]: KeyState)
    $addRef(eax:KeyEvent)
    push    eax
    $call(Option::Some, eax: KeyEvent)
    pop     ebx
    $deref(ebx:KeyEvent)
    jmp     .end
.noKey:
    mov     dword eax, [_enum_Option_None]
.end:
    pop     ebx
    $call(freeMem, ebx)

    pop     ebx
}/

// LOOP

fn sdlSingleLoop<CTX,MODEL>(ctx: CTX, model: MODEL, updateFun: fn(Option<KeyEvent>, MODEL) -> MODEL, renderFun: fn(CTX, MODEL) -> ()) -> MODEL {
    // println("State in sdlSingleLoop");
    // printRef(world);
    let event = keyEvent();

    match(event, { keyEvent ->
        let key = key(keyEvent);
        ifRun(eq(key, 41), { -> exitMain(0);}, { -> }); // 41 -> ESC
    }, { -> });

    let newModel = updateFun(event, model);
    renderFun(ctx, newModel);

    newModel;
}

asm sdlLoop<CTX,MODEL>(ctx: CTX, model: MODEL, update: fn(Option<KeyEvent>, MODEL) -> MODEL, render: fn(CTX, MODEL) -> ()) /{
    push    ebx
    push    ecx
    push    edx

    mov     dword edx, $model
    mov     dword ebx, $model
.loop:
    ; $call(printTotalMemory)
    ; $call(printAllocated)
    ; $call(printTableSlotsAllocated)
    mov     dword ecx, [ebx]
    $call(sdlSingleLoop,$ctx:CTX,ebx:MODEL,$update,$render)
    cmp     dword ebx,eax
    jne     .doRef
    $call(println, "state is the same")
    jmp     .skipRef
.doRef:
    $addRef(eax: MODEL)
    ;$call(println, "New state ")
    ;$printRef(eax:MODEL)
    cmp     ebx,$model
    je      .skipRef
    ;$call(println, "Old state ")
    ; $printRef(ebx:MODEL)
    $deref(ebx: MODEL)
.skipRef:
    mov     dword edx, ebx
    mov     dword ebx, eax
    jmp     .loop

    pop     edx
    pop     ecx
    pop     ebx
}/

// Text

asm sdlTTFInit() -> i32 /{
    $ccall(TTF_Init)
}/

asm sdlOpenFont(file: str, size: i32) -> SDLFont /{
    $ccall(TTF_OpenFont, $file, $size)
}/

asm sdlRenderTextSolid(font: SDLFont, message: str, r: i32, g: i32, b: i32, a: i32) -> SDLSurface /{
    push    ebx
    push    ecx

    $call(malloc, 5, " for temp mem for sdlRenderTextSolid") ; why 5???
    push    eax

    mov     ecx, [eax]
    mov     dword ebx, $r
    mov     byte [ecx], bl
    mov     dword ebx, $g
    mov     byte [ecx + 1], bl
    mov     dword ebx, $b
    mov     byte [ecx + 2], bl
    mov     dword ebx, $a
    mov     byte [ecx + 3], bl

    $ccall(TTF_RenderText_Solid, $font, $message, [ecx])
    pop     ecx
    $call(freeMem, ecx)
    pop     ecx
    pop     ebx
}/

asm sdlRenderTextSolid(font: SDLFont, message: str, color: SDLColor) -> SDLSurface /{
    push    ebx
    push    ecx
    push    edx

    mov     dword edx, $color
    mov     dword edx, [edx]

    $call(malloc, 5, " for temp for sdlRenderTextSolid") ; why 5???
    push    eax

    mov     ecx, [eax]
    mov     dword ebx, [edx]
    mov     byte [ecx], bl
    mov     dword ebx, [edx + 4]
    mov     byte [ecx + 1], bl
    mov     dword ebx, [edx + 8]
    mov     byte [ecx + 2], bl
    mov     dword ebx, [edx + 12]
    mov     byte [ecx + 3], bl

    $ccall(TTF_RenderText_Solid, $font, $message, [ecx])
    pop     ecx
    $call(freeMem, ecx)

    pop     edx
    pop     ecx
    pop     ebx
}/

asm sdlRenderText(ren: SDLRenderer, message: SDLTexture, rect: SDLRect) /{
    push    eax
    mov     dword eax, $rect
    $ccall(SDL_RenderCopy, $ren, $message, 0, [eax])
    pop     eax
}/

struct SDLText {
    surface: SDLSurface,
    texture: SDLTexture
}

fn createSDLText(ren: SDLRenderer, font: SDLFont, text: str, color: SDLColor) -> SDLText {
    let surface = sdlRenderTextSolid(font, text, color);
    let texture = sdlCreateTextureFromSurface(ren, surface);

    SDLText(surface, texture);
}

fn render(ren: SDLRenderer, text: SDLText, rect: SDLRect) {
    sdlRenderText(ren, text.texture, rect);
}

fn renderAndRelease(ren: SDLRenderer, text: SDLText, rect: SDLRect) {
    let texture = text.texture;
    sdlRenderText(ren, texture, rect);
    sdlDestroyTexture(texture);
    sdlFreeSurface(text.surface);
}

fn release(text: SDLText) {
    release(text.texture);
    release(text.surface);
}

fn release(texture: SDLTexture) {
    sdlDestroyTexture(texture);
}

fn release(surface: SDLSurface) {
    sdlFreeSurface(surface);
}