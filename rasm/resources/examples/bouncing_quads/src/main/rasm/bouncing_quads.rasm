/*
time tmp/bouncing_quads 20 (with 10000 quads)

Nasmi386 backend
real    0m0,668s

C backend
real    0m3,772s

time tmp/bouncing_quads 20 (with 50000 quads)

Nasmi386 backend
real    0m2,222s

C backend
real    0m1,519s
*/

struct Model {
    quads: Vec<Quad>,
    fps: FPS,
    font: SDLFont,
    count:int
}

struct Quad {
    x: int,
    y: int,
    xDir: XDirection,
    yDir: YDirection,
    color: SDLColor
}

enum Message {
    KeyMessage(event: KeyEvent),
    Tick
}

const QUADS = 50000;
const WIDTH = 1024;
const HEIGHT = 768;
const QUADWIDTH = 10;
const BLACK = SDLColor(0, 0, 0, 255);
const WHITE = SDLColor(255, 255, 255, 255);

initRandom();

let sdl = sdlInit();

let ttf = sdl.sdlTTFInit();

let font = ttf.sdlOpenFont(resource("DejaVuSerif.ttf"), 24);
let quads = vecRange(0, QUADS)
    .map(fn(it) {
        let x = random(WIDTH);
        let y = random(HEIGHT);
        let xDir = if(random(2).eq(0), Right(), Left());
        let yDir = if(random(2).eq(0), YDirection::Up(), YDirection::Down());
        Quad(x, y, xDir, yDir, SDLColor(random(255), random(255), random(255), 255));
    });
let initialModel = Model(quads, FPS(0, now(), 0), font, argv(1).fmap(toInt).getOrElse(5000));

let win = sdl.sdlCreateWindow("Bouncing quads", 100, 100, WIDTH, HEIGHT);
let ren = sdlCreateRenderer(win);

run(ren, initialModel, update, render, subscriptions);

fn update(message: Message, model: Model) -> Model {
    message.match(fn(keyEvent) {
        if(eq(keyEvent.key, 41), { sdlQuit(); exitMain(0);}, { }); // 41 -> ESC
    }, {});

    let newModel = model
        .quads(model.quads.map(update))
        .fps(model.fps.update)
        .count(model.count.sub(1));

    if(newModel.count.less(0), {sdlQuit(); exitMain(0);}, {});

    newModel;
}

fn update(quad: Quad) -> Quad {
    let px = update(quad.x, quad.xDir, WIDTH.sub(QUADWIDTH));
    let py = update(quad.y, quad.yDir, HEIGHT.sub(QUADWIDTH));
    Quad(px.first, py.first, px.second, py.second, quad.color);
}

fn update<T>(x: int, dir: T, max: int) -> Pair<int, T> {
    let newX = x.move(dir, 1);

    if (x.greater(max),
        Pair(max, dir.flip),
        x.less(0),
        Pair(0, dir.flip),
        Pair(newX, dir));
}

fn render(ren: SDLRenderer, model: Model) {
    sdlSetRenderDrawColor(ren, BLACK);
    sdlRenderClear(ren);

    model.quads.forEach(fn(quad) {
        sdlSetRenderDrawColor(ren, quad.color);
        sdlRenderFillRect(ren, SDLRect(quad.x, quad.y, QUADWIDTH, QUADWIDTH));
    });

    let fpsText = sdlCreateText(ren, model.font, "FPS: ".append(model.fps.fps), WHITE);
    sdlRenderAndRelease(ren, fpsText, 400, 2);

    sdlRenderPresent(ren);
}

fn subscriptions() -> Vec<Message> {
    let event = keyEvent();

    event.match(fn(e) {
        vecOf(KeyMessage(e));
    }, { vecOf(Tick()); });
}