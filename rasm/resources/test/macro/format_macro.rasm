let h = "Joe";
let w = "how do you do";

println(format!("Hello {}, {}{}", h, w, "?"));

pub fn format(s: str, exprs: Vec<ASTExpression>) -> MacroExpressionResult {
    let indexes = s.find("{}");

    let expressions = indexes.zip(exprs, fn(a,b) { Pair(a, b); }).foldLeft(Pair(0, Vec<ASTExpression>()), fn(prev,e) {
        let charIndex = e.first;
        let prefix = s.substr(prev.first, charIndex.sub(prev.first)).orEmpty;
        let newExpressions = 
            prev.second
            .push(ASTValueExpression(ASTStringValue(prefix)))
            .push(e.second);
        Pair(charIndex.add(2), newExpressions);
    });

    let finalExpressions = 
        if(expressions.first.less(s.len.sub(1)), 
            {expressions.second;}, 
            {
                let end = s.substr(expressions.first, s.len.sub(expressions.first)).orEmpty;
                expressions.second.push(stringValue(end));
            });

    let result = finalExpressions.foldLeft(stringValue(""), fn(prev, act) {
        prev.dotAppend(act);
    });

    if(indexes.len.eq(exprs.len), {
        MacroExpression(result);
    }, {
        MacroExpressionResult::MacroError("Expected ".append(exprs.len).add(" parameters, got ".append(indexes.len.toString()));
    });
}


/*
pub fn format(s: str, e1: ASTExpression, e2: ASTExpression) -> MacroExpressionResult {
    let indexes = s.find("{}");

    let expressions = indexes.enumerate.foldLeft(Pair(0, Vec<ASTExpression>()), fn(prev,e) {
        let exprIndex = e.index;
        let charIndex = e.value;
        let prefix = s.substr(prev.first, charIndex.sub(prev.first)).orEmpty;
        let newExpressions = 
            prev.second
            .push(ASTValueExpression(ASTStringValue(prefix)))
            .push(if(exprIndex.eq(0), e1, e2));
        Pair(charIndex.add(2), newExpressions);
    });

    let finalExpressions = 
        if(expressions.first.less(s.len.sub(1)), 
            {expressions.second;}, 
            {
                let end = s.substr(expressions.first, s.len.sub(expressions.first)).orEmpty;
                expressions.second.push(stringValue(end));
            });

    let result = finalExpressions.foldLeft(stringValue(""), fn(prev, act) {
        prev.dotAppend(act);
    });

    if(indexes.len.eq(2), {
        MacroExpression(result);
    }, {
        MacroExpressionResult::MacroError("Expected two parameters, got ".append(indexes.len.toString()));
    });
}
*/

fn orEmpty(o: Option<str>) -> str {
   o.match(fn(s) {s;}, {"";});
}

pub fn toString<F,S>(p: Pair<F,S>) -> str {
    "(".append(p.first).add(", ").append(p.second).add(")");
}

fn find(s: str, v: str) -> Vec<int> {
    vecRange(0, s.len.sub(v.len()).add(1))
    .map(fn(i) {
        Pair(i, s.substr(i, v.len));
    }).filter(fn(it) { 
        it.second.match(fn(found) { found.eq(v); }, { false; });
    })
    .map(fn(it) { it.first; });
}

fn simpleCall(name: str, expressions: Vec<ASTExpression>) -> ASTExpression {
    ASTFunctionCallExpression(ASTFunctionCall(name, expressions, Vec(), None()));
}

fn dotAppend(a: ASTExpression, b: ASTExpression) -> ASTExpression {
    simpleCall("append", vecOf(a, b));
}

fn stringValue(s: str) -> ASTExpression {
    ASTValueExpression(ASTStringValue(s));
}

fn dotAdd(a: ASTExpression, s: str) -> ASTExpression {
    simpleCall("add", vecOf(a, ASTValueExpression(ASTStringValue(s))));
}