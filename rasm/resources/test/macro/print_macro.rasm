let h = "Joe";
let w = "how do you do";

println!("Hello {}, {}{}", h, w, "?");

/*
mprintln("{}, {}!", ASTValueExpression(ASTStringValue(h)), ASTValueExpression(ASTStringValue(w))).match(
    fn(module) { println(module); }, 
    fn(error)  { println(error);  });
*/

pub fn println(s: str, , exprs: Vec<ASTExpression>) -> MacroModuleResult {
    let indexes = s.find("{}");

    let result = indexes.zip(exprs, fn(a,b) { Pair(a, b); }).foldLeft(Pair(0, Vec<ASTExpression>()), fn(prev,e) {
        let charIndex = e.first;
        let prefix = s.substr(prev.first, charIndex.sub(prev.first)).orEmpty;
        let newExpressions = 
            prev.second
            .push(ASTValueExpression(ASTStringValue(prefix)))
            .push(e.second);
        Pair(charIndex.add(2), newExpressions);
    });

    let calls = result.second.map(fn(e) {simpleCall("print", vecOf(e));});

    let finalCalls = 
        if(result.first.less(s.len.sub(1)), 
            {calls;}, 
            {
                let end = s.substr(result.first, s.len.sub(result.first)).orEmpty;
                calls.push(simpleCall("print", vecOf(ASTValueExpression(ASTStringValue(end)))));
            })
        .push(simpleCall("println", Vec()));

    if(indexes.len.eq(exprs.len), {
        MacroModule(ASTModule(
            finalCalls
            , Vec(), Vec(), Vec(), Vec()
        ));
    }, {
        MacroModuleResult::MacroError("Expected ".append(exprs.len).add(" parameters, got ".append(indexes.len.toString()));
    });
}

fn orEmpty(o: Option<str>) -> str {
   o.match(fn(s) {s;}, {"";});
}

pub fn toString<F,S>(p: Pair<F,S>) -> str {
    "(".append(p.first).add(", ").append(p.second).add(")");
}

fn find(s: str, v: str) -> Vec<int> {
    vecRange(0, s.len.sub(v.len()).add(1))
    .map(fn(i) {
        Pair(i, s.substr(i, v.len));
    }).filter(fn(it) { 
        it.second.match(fn(found) { found.eq(v); }, { false; });
    })
    .map(fn(it) { it.first; });
}

fn simpleCall(f: str, parameters: Vec<ASTExpression>) -> ASTStatement {
    ASTExpressionStatement(ASTFunctionCallExpression(ASTFunctionCall(f, parameters, Vec(), None())));
}