struct MockedConnection {}

pub fn testService() {
    when!("save", "findUser", any!(), eq!("aUser"), Ok(User("mocked user")));
    
    println(saveMock(Connection(), "aUser", 10).match(fn(amount) { "saved ".append(amount); }, fn(err) { err;}));
}

fn findUserMocked(conn: Connection, userName: str) -> Result<User,str> {
    Ok(User("mocked user"));
}

pub fn eq(e: ASTExpression) -> MacroExpressionResult {
    MacroExpressionOk(simpleASTCall("eq", vecOf(ASTValueRefExpression("whenParameter"), e)), Vec());
}

pub fn any() -> MacroExpressionResult {
    MacroExpressionOk(booleanASTValue(true), Vec());
}

pub fn when(module: ASTModule, functionToCopy: str, functionName: str, params: Vec<ASTExpression>) -> MacroStatementResult {
    // delete("testmock.log");
    params.last.match(fn(returnValue) {
        let functionParameters = params.take(params.len.sub(1));

        subCall(module, functionToCopy, functionName, functionParameters, returnValue)
        .match(fn(newFunction) {
            MacroStatementOk(Vec(), vecOf(newFunction));
        }, {
            MacroStatementResult::MacroError("cannot find a function ".add(functionToCopy).add(" calling ").add(functionName));
        });        
    }, {
        MacroStatementResult::MacroError("cannot find the return value");
    });    
}

fn subCall(module: ASTModule, name: str, functionCallName: str, params: Vec<ASTExpression>, returnValue: ASTExpression) -> Option<ASTFunctionDef> {
    let newName = name.add("Mock");
    module.functions.findOne(fn(it) { it.name.eq(name); })
        .match(fn(function) {
            let newBody = function.body.match(
                fn(rasmBody) {
                    let newBody = 
                        rasmBody.map(fn(it) { changeCall(it, functionCallName, params, returnValue);});
                    RASMBody(newBody);
                },
                fn(nativeBody) { function.body; }
            );
            Some(function.name(newName).body(newBody));
        }, {
            None();
        });
}

fn changeCall(stmt: ASTStatement, functionCallName: str, params: Vec<ASTExpression>, returnValue: ASTExpression) -> ASTStatement {
    stmt.match(
        fn(expr) {  
            ASTExpressionStatement(changeCall(expr, functionCallName, params, returnValue));
        }, 
        fn(s, expr) { ASTLetStatement(s, changeCall(expr, functionCallName, params, returnValue)); }, 
        fn(s, expr, modifiers) { ASTConstStatement(s, changeCall(expr, functionCallName, params, returnValue), modifiers); }
    );
}

fn changeCall(expr: ASTExpression, functionCallName: str, params: Vec<ASTExpression>, returnValue: ASTExpression) -> ASTExpression {
    expr.match(
        fn(call) {
            if (call.functionName.eq(functionCallName).and(params.len.eq(call.parameters.len)), {
                let parameterLambdas = call.parameters.zip(params, fn(cp, p) {
                    let body = vecOf(
                        ASTLetStatement("whenParameter", cp), 
                        ASTLetStatement("whenParameterResult", p),
                        ASTExpressionStatement(ASTValueRefExpression("whenParameterResult"))
                    );
                    ASTLambdaExpression(ASTLambdaDef(Vec(), body));
                });

                let newCall = simpleASTCall("if", vecOf(
                    simpleASTCall("allTrue", vecOf(simpleASTCall("vecOf", parameterLambdas))), 
                    simpleLambda(returnValue), 
                    simpleLambda(expr)
                ));

                newCall;
            }, {
                let newParameters = call.parameters.map(fn(it) { changeCall(it, functionCallName, params, returnValue);});
                ASTFunctionCallExpression(call.parameters(newParameters));
            });
        }, 
        fn(s) { expr; }, 
        fn(value) { expr; }, 
        fn(lambda) {
            let newBody = lambda.body.map(fn(it) { changeCall(it, functionCallName, params, returnValue);});
            ASTLambdaExpression(lambda.body(newBody));
        });
}

fn simpleLambda(expr: ASTExpression) -> ASTExpression {
    ASTLambdaExpression(ASTLambdaDef(Vec(), vecOf(ASTExpressionStatement(expr))));
}

/*
    if(allTrue(vecOf({
        let whenParameter = conn;
        true;
    },{
        let whenParameter = userName;
        eq(whenParameter, "aUser");
    })), returnValue, call());
*/

pub fn allTrue(vec: Vec<fn() -> bool>) -> bool {
    vec.foldLeft(true, fn(prev,actual) { prev.and(actual.call);});
}

fn changePar(expr: ASTExpression, newExpr: ASTExpression) -> ASTExpression {
    expr.match(
        fn(call) {  
            let newCall = 
                call.parameters.map(changePar.curryRight(newExpr));
            ASTFunctionCallExpression(newCall);
        }, 
        fn(s) { if(s.eq("whenParameter"), newExpr, expr); }, 
        fn(value) { expr; }, 
        fn(lambda) { 
            expr;
        });
}

pub fn toString<T,E>(result: Result<T,E>) -> str {
    result.match(
        fn(value) { "OK(".append(value).add(")");},
        fn(error) { "Error(".append(error).add(")");
    });
}

fn log(message: str) {
    let actual = if(fileExists("testmock.log"), {
        readFile("testmock.log");
    }, { ""; });

    let f = createFile("testmock.log");
    print(f, actual).or(println(f, message)).toUnit;
    
    f.close();
}