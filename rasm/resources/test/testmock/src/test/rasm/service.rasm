struct MockedConnection {}

pub fn testService() {
    let saveMock = when!("save", "findUser", any!(), eq!("aUser"), Ok<User,str>(User("mocked user")));
    // whenCopy!("save", "findUser", any!(), eq!("aUser"), Ok<User,str>(User("mocked user")));
    
    println(saveMock(Connection(), "aUser", 10).match(fn(amount) { "saved ".append(amount); }, fn(err) { err;}));
}

pub fn eq(e: ASTExpression) -> MacroExpressionResult {
    MacroExpressionOk(simpleASTCall("eq", vecOf(ASTValueRefExpression("whenParameter"), e)), Vec());
}

pub fn any() -> MacroExpressionResult {
    MacroExpressionOk(booleanASTValue(true), Vec());
}

/**
    it copies the function with name functionToCopy, to functionToCopy+"Mock", and substitutes the call to functionName,
    matching the parameters with the given expressions, but not the last which is the expression of the result.
    It does not return nothing. It works even with generic funtions.

    For example given this macro call:
    
    whenCopy!("save", "findUser", any!(), eq!("aUser"), Ok<User,str>(User("mocked user")));

    a saveMock function will be created and if there's a call to findUser, with two parameters, the first any, the second
    the string "aUser", then Ok<User,str>(User("mocked user")) is returned instead.
*/
pub fn whenCopy(module: ASTModule, functionToCopy: str, functionName: str, params: Vec<ASTExpression>) -> MacroStatementResult {
    // delete("testmock.log");
    params.last.match(fn(returnValue) {
        let functionParameters = params.take(params.len.sub(1));
        let newName = functionToCopy.add("Mock");

        subCall(module, functionToCopy, functionName, functionParameters, returnValue, newName)
        .match(fn(newFunction) {
            MacroStatementOk(Vec(), vecOf(newFunction));
        }, {
            MacroStatementResult::MacroError("cannot find a function ".add(functionToCopy).add(" calling ").add(functionName));
        });        
    }, {
        MacroStatementResult::MacroError("cannot find the return value");
    });    
}

/**
    it copies the function with name functionToCopy, to functionToCopy+"Mock"+random, and substitutes the call to functionName,
    matching the parameters with the given expressions, but not the last which is the expression of the result.
    It returns a reference to the new function. It does NOT work with generic funtions.

    For example given this macro call:
    
    whenCopy!("save", "findUser", any!(), eq!("aUser"), Ok<User,str>(User("mocked user")));

    a saveMock+random function will be created and if there's a call to findUser, with two parameters, the first any, the second
    the string "aUser", then Ok<User,str>(User("mocked user")) is returned insted. 
    A reference to the saveMock+random function is returned.
*/
pub fn when(module: ASTModule, functionToCopy: str, functionName: str, params: Vec<ASTExpression>) -> MacroExpressionResult {
    // delete("testmock.log");
    params.last.match(fn(returnValue) {
        let functionParameters = params.take(params.len.sub(1));

        initRandom();

        let newName = functionToCopy.add("Mock").append(random(100000));

        subCall(module, functionToCopy, functionName, functionParameters, returnValue, newName)
        .match(fn(newFunction) {
            MacroExpressionOk(ASTValueRefExpression(newFunction.name), vecOf(newFunction));
        }, {
            MacroExpressionResult::MacroError("cannot find a function ".add(functionToCopy).add(" calling ").add(functionName));
        });        
    }, {
        MacroExpressionResult::MacroError("cannot find the return value");
    });    
}

fn subCall(module: ASTModule, name: str, functionCallName: str, params: Vec<ASTExpression>, returnValue: ASTExpression, newName: str) -> Option<ASTFunctionDef> {
    module.functions.findOne(fn(it) { it.name.eq(name); })
        .match(fn(function) {
            let newBody = function.body.match(
                fn(rasmBody) {
                    let newBody = 
                        rasmBody.map(fn(it) { changeCall(it, functionCallName, params, returnValue);});
                    RASMBody(newBody);
                },
                fn(nativeBody) { function.body; }
            );
            Some(function.name(newName).body(newBody));
        }, {
            None();
        });
}

fn changeCall(stmt: ASTStatement, functionCallName: str, params: Vec<ASTExpression>, returnValue: ASTExpression) -> ASTStatement {
    stmt.match(
        fn(expr) {  
            ASTExpressionStatement(changeCall(expr, functionCallName, params, returnValue));
        }, 
        fn(s, expr) { ASTLetStatement(s, changeCall(expr, functionCallName, params, returnValue)); }, 
        fn(s, expr, modifiers) { ASTConstStatement(s, changeCall(expr, functionCallName, params, returnValue), modifiers); }
    );
}

fn changeCall(expr: ASTExpression, functionCallName: str, params: Vec<ASTExpression>, returnValue: ASTExpression) -> ASTExpression {
    expr.match(
        fn(call) {
            if (call.functionName.eq(functionCallName).and(params.len.eq(call.parameters.len)), {
                let parameterLambdas = call.parameters.zip(params, fn(cp, p) {
                    let body = vecOf(
                        ASTLetStatement("whenParameter", cp), 
                        ASTLetStatement("whenParameterResult", p),
                        ASTExpressionStatement(ASTValueRefExpression("whenParameterResult"))
                    );
                    ASTLambdaExpression(ASTLambdaDef(Vec(), body));
                });

                let newCall = simpleASTCall("if", vecOf(
                    simpleASTCall("allTrue", vecOf(simpleASTCall("vecOf", parameterLambdas))), 
                    simpleLambda(returnValue), 
                    simpleLambda(expr)
                ));

                newCall;
            }, {
                let newParameters = call.parameters.map(fn(it) { changeCall(it, functionCallName, params, returnValue);});
                ASTFunctionCallExpression(call.parameters(newParameters));
            });
        }, 
        fn(s) { expr; }, 
        fn(value) { expr; }, 
        fn(lambda) {
            let newBody = lambda.body.map(fn(it) { changeCall(it, functionCallName, params, returnValue);});
            ASTLambdaExpression(lambda.body(newBody));
        });
}

fn simpleLambda(expr: ASTExpression) -> ASTExpression {
    ASTLambdaExpression(ASTLambdaDef(Vec(), vecOf(ASTExpressionStatement(expr))));
}

pub fn allTrue(vec: Vec<fn() -> bool>) -> bool {
    vec.foldLeft(true, fn(prev,actual) { prev.and(actual.call);});
}

fn changePar(expr: ASTExpression, newExpr: ASTExpression) -> ASTExpression {
    expr.match(
        fn(call) {  
            let newCall = 
                call.parameters.map(changePar.curryRight(newExpr));
            ASTFunctionCallExpression(newCall);
        }, 
        fn(s) { if(s.eq("whenParameter"), newExpr, expr); }, 
        fn(value) { expr; }, 
        fn(lambda) { 
            expr;
        });
}

pub fn toString<T,E>(result: Result<T,E>) -> str {
    result.match(
        fn(value) { "OK(".append(value).add(")");},
        fn(error) { "Error(".append(error).add(")");
    });
}

fn log(message: str) {
    let actual = if(fileExists("testmock.log"), {
        readFile("testmock.log");
    }, { ""; });

    let f = createFile("testmock.log");
    print(f, actual).or(println(f, message)).toUnit;
    
    f.close();
}