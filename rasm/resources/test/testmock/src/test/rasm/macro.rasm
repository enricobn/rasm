pub fn copyFunction(module: ASTModule, name: str, newName:str, originalCallName: str, newCallName: str) -> MacroModuleResult {
    module.functions.findOne(fn(it) { it.name.eq(name); })
        .match(fn(it) {
            let newBody = it.body.match(
                fn(rasmBody) {
                    let newBody = 
                        rasmBody.map(changeCall.curry(originalCallName, newCallName));
                    
                    RASMBody(newBody);
                },
                fn(nativeBody) { it.body; }
            );
            let newModule = ASTModule(Vec(), vecOf(it.name(newName).body(newBody)), Vec(), Vec(), Vec());
        
            MacroModule(newModule);
        }, {
            MacroError("cannot find unique function");
        });
}

fn changeCall(originalCallName: str, newCallName: str, stmt: ASTStatement) -> ASTStatement {
    stmt.expr(changeCall.curry(originalCallName, newCallName));
}

fn expr(stmt: ASTStatement, mapFunction: fn(ASTExpression) -> ASTExpression) -> ASTStatement {
    stmt.match(
        fn(expr) {  
            ASTExpressionStatement(mapFunction(expr));
        }, 
        fn(s, expr) { ASTLetStatement(s, mapFunction(expr)); }, 
        fn(s, expr, modifiers) { ASTConstStatement(s, mapFunction(expr), modifiers); }
    );
}

fn changeCall(originalCallName: str, newCallName: str, expr: ASTExpression) -> ASTExpression {
    expr.match(
        fn(call) {  
            let newCall = 
                if(call.functionName.eq(originalCallName), 
                    { call.functionName(newCallName);}, 
                    { call; }
                )
                .parameters(call.parameters.map(changeCall.curry(originalCallName, newCallName)));
            ASTFunctionCallExpression(newCall);
        }, 
        fn(s) { expr; }, 
        fn(value) { expr; }, 
        fn(lambda) { 
            ASTLambdaExpression(lambda.body(lambda.body.map(
                changeCall.curry(originalCallName, newCallName)
            ))); 
        });
}

pub fn evaluate(expr: ASTExpression) -> MacroExpressionResult {
    MacroExpression(expr);
}

fn findOne<T>(v: Vec<T>, condition: fn(T) -> bool) -> Option<T> {
    let elements = v.filter(condition);
    if(elements.len.eq(1), {
        elements.first();
    }, {
        None<T>();
    });
}

pub fn printFunctions(module: ASTModule) -> MacroModuleResult {
    let functions = module.functions.map(fn(it) { it.name; });

    let statement = ASTExpressionStatement(simpleASTCall("println", vecOf(stringASTValue(functions.toString))));

    let newModule = ASTModule(vecOf(statement), Vec(), Vec(), Vec(), Vec());
    
    MacroModule(newModule);
}